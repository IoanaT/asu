{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "97b470e14726ef3628924dde59f4647a",
     "grade": false,
     "grade_id": "cell-1a02bff32a097b76",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "# Assignment 3\n",
    "\n",
    "In this assignment we will be build a multi layer neural network and train it to classify hand-written digits into 10 classes (digits 0-9). Assignment 3 will build upon the learning from Assignment 2. We will extend Assignment 2 by introducing optmization techniques like dropout, momentum and learning_rate scheduling and use of minibatch gradient descent"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "bd5ac0db59406e661d8ef88be3baa17a",
     "grade": false,
     "grade_id": "cell-d9bd60ff8a7a5aba",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "#import libraries and functions to load the data\n",
    "from digits import get_mnist\n",
    "from matplotlib import pyplot as plt\n",
    "import numpy as np\n",
    "import ast\n",
    "import sys\n",
    "import numpy.testing as npt\n",
    "import pytest\n",
    "import random\n",
    "from IPython.core.debugger import set_trace"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "2d8b8402ab293c269aef902b1afe21ca",
     "grade": false,
     "grade_id": "cell-7e789c2d07d0df38",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "## Load and Visualize Data\n",
    "\n",
    "MNIST dataset contains grayscale samples of handwritten digits of size 28 $\\times$ 28. It is split into training set of 60,000 examples, and a test set of 10,000 examples. We will use the entire dataset for training. Since we plan to use minibatch gradient descent, we can work with a larger dataset and not worry if it will fit into memory. You will also see the improved speed of minibatch gradient descent compared to Assignment 2, where we used batch gradeint descent (using the entire training data as a batch)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "8ca9098028d932a01a5cc12ac78b384e",
     "grade": false,
     "grade_id": "cell-153e3e96f279c5f5",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "trX.shape:  (784, 60000)\n",
      "trY.shape:  (1, 60000)\n",
      "tsX.shape:  (784, 10000)\n",
      "tsY.shape:  (1, 10000)\n",
      "Train max: value = 1.0, Train min: value = -1.0\n",
      "Test max: value = 1.0, Test min: value = -1.0\n",
      "Unique labels in train:  [0 1 2 3 4 5 6 7 8 9]\n",
      "Unique labels in test:  [0 1 2 3 4 5 6 7 8 9]\n",
      "\n",
      "Displaying a few samples\n",
      "labels\n",
      "[[5 0 4 1 9 2 1 3 1 4]\n",
      " [3 5 3 6 1 7 2 8 6 9]\n",
      " [4 0 9 1 1 2 4 3 2 7]\n",
      " [3 8 6 9 0 5 6 0 7 6]\n",
      " [1 8 7 9 3 9 8 5 9 3]\n",
      " [7 2 1 0 4 1 4 9 5 9]\n",
      " [0 6 9 0 1 5 9 7 3 4]\n",
      " [9 6 6 5 4 0 7 4 0 1]\n",
      " [3 1 3 4 7 2 7 1 2 1]\n",
      " [1 7 4 2 3 5 1 2 4 4]]\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 576x576 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "random.seed(1)\n",
    "np.random.seed(1)\n",
    "trX, trY, tsX, tsY = get_mnist()\n",
    "# We need to reshape the data everytime to match the format (d,m), where d is dimensions (784) and m is number of samples\n",
    "trX = trX.reshape(-1, 28*28).T\n",
    "trY = trY.reshape(1, -1)\n",
    "tsX = tsX.reshape(-1, 28*28).T\n",
    "tsY = tsY.reshape(1, -1)\n",
    "    \n",
    "# Lets examine the data and see if it is normalized\n",
    "print('trX.shape: ', trX.shape)\n",
    "print('trY.shape: ', trY.shape)\n",
    "print('tsX.shape: ', tsX.shape)\n",
    "print('tsY.shape: ', tsY.shape)\n",
    "print('Train max: value = {}, Train min: value = {}'.format(np.max(trX), np.min(trX)))\n",
    "print('Test max: value = {}, Test min: value = {}'.format(np.max(tsX), np.min(tsX)))\n",
    "print('Unique labels in train: ', np.unique(trY))\n",
    "print('Unique labels in test: ', np.unique(tsY))\n",
    "\n",
    "# Let's visualize a few samples and their labels from the train and test datasets.\n",
    "print('\\nDisplaying a few samples')\n",
    "visx = np.concatenate((trX[:,:50],tsX[:,:50]), axis=1).reshape(28,28,10,10).transpose(2,0,3,1).reshape(28*10,-1)\n",
    "visy = np.concatenate((trY[:,:50],tsY[:,:50]), axis=1).reshape(10,-1)\n",
    "    \n",
    "print('labels')\n",
    "print(visy)\n",
    "plt.figure(figsize = (8,8))\n",
    "plt.axis('off')\n",
    "plt.imshow(visx, cmap='gray');"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "37df5ec899c09d162a1714cd03e601a2",
     "grade": false,
     "grade_id": "cell-e77c10bfbde99f2c",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "## Reuse Code from Assignment 2\n",
    "\n",
    "There are some sections in this assignment which require you to use the code you implemented for Assignment 2. These sections need to work correctly for Assignment 3 to be successful. However, these sections will not have any points assigned to them. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "7221fc5c8438626f55fed907bdbdeb70",
     "grade": false,
     "grade_id": "cell-36f264bd171e66a2",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Rectified Linear Unit-ReLU (repeated from Assignment 2:   0 points)\n",
    "\n",
    "ReLU (Rectified Linear Unit) is a piecewise linear function defined as\n",
    "\\begin{equation*}\n",
    "ReLU(Z) = \\text{max}(0,Z)\n",
    "\\end{equation*}\n",
    "\n",
    "Hint: use [numpy.maximum](https://docs.scipy.org/doc/numpy/reference/generated/numpy.maximum.html)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "305c954ece9e4a95d802995ee253af50",
     "grade": false,
     "grade_id": "test_case1_relu_soln",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def relu(Z):\n",
    "    '''\n",
    "    Computes relu activation of input Z\n",
    "    \n",
    "    Inputs: \n",
    "        Z: numpy.ndarray (n, m) which represent 'm' samples each of 'n' dimension\n",
    "        \n",
    "    Outputs: \n",
    "        A: where A = ReLU(Z) is a numpy.ndarray (n, m) representing 'm' samples each of 'n' dimension\n",
    "        cache: a dictionary with {\"Z\", Z}\n",
    "        \n",
    "    '''\n",
    "    cache = {}\n",
    "    # your code here\n",
    "    A = np.maximum(0,Z)\n",
    "    cache[\"Z\"]=Z\n",
    "    \n",
    "    return A, cache"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "d68ac986a1737d197092d30d8807deb6",
     "grade": true,
     "grade_id": "test_case1_relu",
     "locked": true,
     "points": 0,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "#Test\n",
    "z_tst = [-2,-1,0,1,2]\n",
    "a_tst, c_tst = relu(z_tst)\n",
    "npt.assert_array_equal(a_tst,[0,0,0,1,2])\n",
    "npt.assert_array_equal(c_tst[\"Z\"], [-2,-1,0,1,2])\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "0f49ae7f620c77d0e403a032c633e256",
     "grade": false,
     "grade_id": "cell-9e69ac398fc920e4",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### ReLU - Gradient (repeated from Assignment 2:   0 points)\n",
    "\n",
    "The gradient of ReLu($Z$) is 1 if $Z>0$ else it is 0."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "dc140b793336a33c53c1fe2d27397f57",
     "grade": false,
     "grade_id": "test_case2_relu_der_soln",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def relu_der(dA, cache):\n",
    "    '''\n",
    "    Computes derivative of relu activation\n",
    "    \n",
    "    Inputs: \n",
    "        dA: derivative from the subsequent layer of dimension (n, m). \n",
    "            dA is multiplied elementwise with the gradient of ReLU\n",
    "        cache: dictionary with {\"Z\", Z}, where Z was the input \n",
    "            to the activation layer during forward propagation\n",
    "        \n",
    "    Outputs: \n",
    "        dZ: the derivative of dimension (n,m). It is the elementwise \n",
    "            product of the derivative of ReLU and dA\n",
    "        \n",
    "    '''\n",
    "    dZ = np.array(dA, copy=True)\n",
    "    Z = cache[\"Z\"]\n",
    "    # your code here\n",
    "    for i in range(Z.shape[0]):\n",
    "        for j in range(Z.shape[1]):\n",
    "            if Z[i][j] > 0:\n",
    "                dZ[i][j]=dA[i][j]\n",
    "            else:\n",
    "                dZ[i][j]=0\n",
    "    \n",
    "    return dZ"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "7f852b01b4c73d0b30c98a2ec928f88b",
     "grade": true,
     "grade_id": "test_case2_relu_der",
     "locked": true,
     "points": 0,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "#Test\n",
    "dA_tst = np.array([[0,2],[1,1]])\n",
    "cache_tst = {}\n",
    "cache_tst['Z'] = np.array([[-1,2],[1,-2]])\n",
    "npt.assert_array_equal(relu_der(dA_tst,cache_tst),np.array([[0,2],[1,0]]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "bd03aee42ab92a4b63da967f3759c88e",
     "grade": false,
     "grade_id": "cell-ff93df0fc4bbc430",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Linear activation and its derivative (repeated from Assignment 2)\n",
    "\n",
    "There is no activation involved here. It is an identity function. \n",
    "\\begin{equation*}\n",
    "\\text{Linear}(Z) = Z\n",
    "\\end{equation*}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "695ee8c0246dcc69a45cdcc2b32e07cb",
     "grade": false,
     "grade_id": "cell-5c19d5fd5d97fb3e",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def linear(Z):\n",
    "    '''\n",
    "    Computes linear activation of Z\n",
    "    This function is implemented for completeness\n",
    "        \n",
    "    Inputs: \n",
    "        Z: numpy.ndarray (n, m) which represent 'm' samples each of 'n' dimension\n",
    "        \n",
    "    Outputs: \n",
    "        A: where A = Linear(Z) is a numpy.ndarray (n, m) representing 'm' samples each of 'n' dimension\n",
    "        cache: a dictionary with {\"Z\", Z}   \n",
    "    '''\n",
    "    A = Z\n",
    "    cache = {}\n",
    "    cache[\"Z\"] = Z\n",
    "    return A, cache\n",
    "\n",
    "\n",
    "def linear_der(dA, cache):\n",
    "    '''\n",
    "    Computes derivative of linear activation\n",
    "    This function is implemented for completeness\n",
    "    \n",
    "    Inputs: \n",
    "        dA: derivative from the subsequent layer of dimension (n, m). \n",
    "            dA is multiplied elementwise with the gradient of Linear(.)\n",
    "        cache: dictionary with {\"Z\", Z}, where Z was the input \n",
    "            to the activation layer during forward propagation\n",
    "        \n",
    "    Outputs: \n",
    "        dZ: the derivative of dimension (n,m). It is the elementwise \n",
    "            product of the derivative of Linear(.) and dA\n",
    "    '''      \n",
    "    dZ = np.array(dA, copy=True)\n",
    "    return dZ"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "ce35f78ff70d66940badc942b348ebf3",
     "grade": false,
     "grade_id": "cell-076c0de6c87fa8af",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Softmax Activation and Cross-entropy Loss Function (repeated from Assignment 2:  0 points)\n",
    "\n",
    "The softmax activation is computed on the outputs from the last layer and the output label with the maximum probablity is predicted as class label. The softmax function can also be refered as normalized exponential function which takes a vector of $n$ real numbers as input, and normalizes it into a probability distribution consisting of $n$ probabilities proportional to the exponentials of the input numbers.\n",
    "\n",
    "The input to the softmax function is the $(n \\times m)$ matrix, $ Z = [ z^{(1)} , z^{(2)}, \\ldots, z^{(m)} ] $, where $z^{(i)}$ is the $i^{th}$ sample of $n$ dimensions. We estimate the softmax for each of the samples $1$ to $m$. The softmax activation for sample $z^{(i)}$ is $a^{(i)} = \\text{softmax}(z^{(i)})$, where the components of $a^{(i)}$ are,\n",
    "\\begin{equation}\n",
    "a_k{(i)} = \\frac{\\text{exp}(z^{(i)}_k)}{\\sum_{k = 1}^{n}\\text{exp}(z^{(i)}_k)} \\qquad \\text{for} \\quad 1\\leq k\\leq n\n",
    "\\end{equation}\n",
    "\n",
    "The output of the softmax is $ A = [ a^{(1)} , a^{(2)} .... a^{(m)} ]$, where $a^{(i)} = [a^{(i)}_1,a^{(i)}_2, \\ldots, a^{(i)}_n]^\\top$.  In order to avoid floating point overflow, we subtract a constant from all the input components of $z^{(i)}$ before calculating the softmax. This constant is $z_{max}$, where, $z_{max} = \\text{max}(z_1,z_2,...z_n)$. The activation is given by,\n",
    "\n",
    "\\begin{equation}\n",
    "a_k{(i)} = \\frac{\\text{exp}(z^{(i)}_k- z_{max})}{\\sum_{k = 1}^{n}\\text{exp}(z^{(i)}_k - z_{max})} \\qquad \\text{for} \\quad 1\\leq k\\leq n\n",
    "\\end{equation}\n",
    "\n",
    "If the output of softmax is given by $A$ and the ground truth is given by $Y = [ y^{(1)} , y^{(2)}, \\ldots, y^{(m)}]$, the cross entropy loss between the predictions $A$ and groundtruth labels $Y$ is given by,\n",
    "\n",
    "\\begin{equation}\n",
    "Loss(A,Y) = - \\frac{1}{m} \\sum_{i=1}^m \\sum_{k=1}^{n}I \\{ y^i = k \\} \\text{log}a_k^i\n",
    "\\end{equation}\n",
    "\n",
    "\n",
    "where $I$ is the identity function given by \n",
    "\n",
    "\\begin{equation}\n",
    "I\\{\\text{condition}\\} = 1, \\quad \\text{if condition = True}\\\\\n",
    "I\\{\\text{condition}\\} = 0, \\quad \\text{if condition = False}\\\\\n",
    "\\end{equation}\n",
    "Hint: use [numpy.exp](https://docs.scipy.org/doc/numpy/reference/generated/numpy.exp.html)\n",
    "numpy.max,\n",
    "[numpy.sum](https://docs.scipy.org/doc/numpy/reference/generated/numpy.sum.html)\n",
    "[numpy.log](https://docs.scipy.org/doc/numpy/reference/generated/numpy.log.html)\n",
    "Also refer to use of 'keepdims' and 'axis' parameter."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "96ce0af0b0c8a2cbe0176be9a65aaf55",
     "grade": false,
     "grade_id": "test_case3_softmax_soln",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def softmax_cross_entropy_loss(Z, Y=np.array([])):\n",
    "    '''\n",
    "    Computes the softmax activation of the inputs Z\n",
    "    Estimates the cross entropy loss\n",
    "\n",
    "    Inputs: \n",
    "        Z: numpy.ndarray (n, m)\n",
    "        Y: numpy.ndarray (1, m) of labels\n",
    "            when y=[] loss is set to []\n",
    "    \n",
    "    Outputs:\n",
    "        A: numpy.ndarray (n, m) of softmax activations\n",
    "        cache: a dictionary to store the activations which will be used later to estimate derivatives\n",
    "        loss: cost of prediction\n",
    "    '''\n",
    "    \n",
    "    # your code here\n",
    "    A=np.copy(Z)\n",
    "    if (Y.size == 0):\n",
    "        loss = []\n",
    "    else:\n",
    "        loss = 0\n",
    "    m = Z.shape[1]\n",
    "    for col in range(Z.shape[1]):\n",
    "        \n",
    "        sum_exp = np.sum(np.exp(Z[:,col]))\n",
    "        for row in range(Z.shape[0]):\n",
    "            A[row][col]=np.exp(Z[row][col])/sum_exp\n",
    "            if (Y.size!=0 and Y[0][col]==row):\n",
    "                loss = loss + np.log(A[row][col])\n",
    "   \n",
    "    if (Y.size != 0):\n",
    "        loss = -1/m * loss \n",
    "        \n",
    "    cache = {}\n",
    "    cache[\"A\"] = A\n",
    "    return A, cache, loss"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "ba99e7e708852e0c35b5b6f3665d239d",
     "grade": true,
     "grade_id": "test_case3_softmax",
     "locked": true,
     "points": 0,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "#test cases for softmax_cross_entropy_loss\n",
    "np.random.seed(1)\n",
    "Z_t = np.random.randn(3,4)\n",
    "Y_t = np.array([[1,0,1,2]])\n",
    "A_t = np.array([[0.57495949, 0.38148818, 0.05547572, 0.36516899],\n",
    "       [0.26917503, 0.07040735, 0.53857622, 0.49875847],\n",
    "       [0.15586548, 0.54810447, 0.40594805, 0.13607254]])\n",
    "\n",
    "A_est, cache_est, loss_est = softmax_cross_entropy_loss(Z_t, Y_t)\n",
    "npt.assert_almost_equal(loss_est,1.2223655548779273,decimal=5)\n",
    "npt.assert_array_almost_equal(A_est,A_t,decimal=5)\n",
    "npt.assert_array_almost_equal(cache_est['A'],A_t,decimal=5)\n",
    "\n",
    "# hidden test cases follow"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "cf8515684585cafb58a9d922e3a8720b",
     "grade": false,
     "grade_id": "cell-5151a9f9720ee789",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Derivative of the softmax_cross_entropy_loss(.) (repeated from Assignment 2   -   0 points)\n",
    "\n",
    "We discused in the lecture that it is easier to directly estimate $dZ$ which is $\\frac{dL}{dZ}$, where $Z$ is the input to the *softmax_cross_entropy_loss($Z$)* function. \n",
    "\n",
    "Let $Z$ be the $(n\\times m)$ dimension input and $Y$ be the $(1,m)$ groundtruth labels. If $A$ is the $(n\\times m)$ matrix of softmax activations of $Z$, the derivative $dZ$ is given by, \n",
    "\n",
    "\\begin{equation}\n",
    "dZ =\\frac{1}{m} (A -\\bar{Y})\n",
    "\\end{equation}\n",
    "\n",
    "where, $\\bar{Y}$ is the one-hot representation of $Y$. \n",
    "\n",
    "One-hot encoding is a binary representation of the discrete class labels. For example, let $y^{(i)}\\in\\{0,1,2\\}$ for a 3-category problem. Assume there are $m=4$ data points. In this case $Z$ will be a $3 \\times 4$ matrix. Let the categories of the 4 data points be $Y=[1,0,1,2]$. The one hot representation is given by, \n",
    "\\begin{equation}\n",
    "\\bar{Y} = \n",
    "    \\begin{bmatrix}\n",
    "    0 ~ 1 ~ 0 ~ 0\\\\\n",
    "    1 ~ 0 ~ 1 ~ 0\\\\\n",
    "    0 ~ 0 ~ 0 ~ 1\n",
    "    \\end{bmatrix}\n",
    "\\end{equation}\n",
    "where, the one-hot encoding for label $y^{(1)} = 1$ is $\\bar{y}^{(1)} = [0, 1, 0]^\\top$. Similarly, the one-hot encoding for $y^{(4)} = 2$ is $\\bar{y}^{(4)} = [0, 0, 1]^\\top$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "e131cd252e51deebb53d920f975a4ac5",
     "grade": false,
     "grade_id": "test_case4_softmax_der_soln",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def softmax_cross_entropy_loss_der(Y, cache):\n",
    "    '''\n",
    "    Computes the derivative of the softmax activation and cross entropy loss\n",
    "\n",
    "    Inputs: \n",
    "        Y: numpy.ndarray (1, m) of labels\n",
    "        cache: a dictionary with cached activations A of size (n,m)\n",
    "\n",
    "    Outputs:\n",
    "        dZ: derivative dL/dZ - a numpy.ndarray of dimensions (n, m) \n",
    "    '''\n",
    "    A = cache[\"A\"]\n",
    "    # your code here\n",
    "    dZ = np.copy(A)\n",
    "    m = Y.shape[1]\n",
    "    for col in range(A.shape[1]):\n",
    "\n",
    "        for row in range(A.shape[0]):\n",
    "           \n",
    "            if (Y[0][col]==row):\n",
    "                dZ[row][col]= 1/m * (A[row][col] - 1)\n",
    "            else:\n",
    "                dZ[row][col]= 1/m * A[row][col] \n",
    "    \n",
    "    return dZ"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "ddb4d9c5e4005c7f4a06cac3537c2c61",
     "grade": true,
     "grade_id": "test_case4_softmax_der",
     "locked": true,
     "points": 0,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "#test cases for softmax_cross_entropy_loss_der\n",
    "np.random.seed(1)\n",
    "Z_t = np.random.randn(3,4)\n",
    "Y_t = np.array([[1,0,1,2]])\n",
    "A_t = np.array([[0.57495949, 0.38148818, 0.05547572, 0.36516899],\n",
    "       [0.26917503, 0.07040735, 0.53857622, 0.49875847],\n",
    "       [0.15586548, 0.54810447, 0.40594805, 0.13607254]])\n",
    "cache_t={}\n",
    "cache_t['A'] = A_t\n",
    "dZ_t = np.array([[ 0.14373987, -0.15462795,  0.01386893,  0.09129225],\n",
    "       [-0.18270624,  0.01760184, -0.11535594,  0.12468962],\n",
    "       [ 0.03896637,  0.13702612,  0.10148701, -0.21598186]])\n",
    "\n",
    "dZ_est = softmax_cross_entropy_loss_der(Y_t, cache_t)\n",
    "npt.assert_almost_equal(dZ_est,dZ_t,decimal=5)\n",
    "\n",
    "# hidden test cases follow"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Dropout forward (10 points)\n",
    "\n",
    "The dropout layer is introduced to improve regularization by reducing overfitting. The layer will zero out some of the activations in the input based on the 'drop_prob' value. Dropout is only appiled in 'train' mode and not in 'test' mode. In the 'test' mode the output activations are the same as input activations. \n",
    "We will implement the inverted droput method we discussed in the lecture. We define 'prob_keep' as the percentage of activations remaining after dropout, if drop_out = 0.3, then prob_keep = 0.7, i.e., 70% of the activations are retained after dropout. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "6b4627af274670c942f2376fe2bac46f",
     "grade": false,
     "grade_id": "cell-e97aa827e6a861ff",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def dropout(A, drop_prob, mode='train'):\n",
    "        '''\n",
    "        Using the 'inverted dropout' technique to implement dropout regularization.\n",
    "        Inputs:\n",
    "            A: Activation input before dropout is applied - shape is (n,m)\n",
    "            drop_prob: dropout parameter. If drop_prob = 0.3, we drop 30% of the neuron activations\n",
    "            mode: Dropout acts differently in training and testing mode. Hence, mode is a parameter which\n",
    "                takes in only 2 values, 'train' or 'test'\n",
    "\n",
    "        Outputs:\n",
    "            A: Output of shape (n,m), with some values masked out and other values scaled to account for missing values\n",
    "            cache: a tuple which stores the drop_prob, mode and mask for use in backward pass.\n",
    "        '''\n",
    "        # When there is no dropout return the same activation\n",
    "        mask = None\n",
    "        if drop_prob == 0:\n",
    "            cache = (drop_prob, mode, mask)\n",
    "            return A, cache\n",
    "        \n",
    "        # The prob_keep is the percentage of activations remaining after dropout\n",
    "        # if drop_out = 0.3, then prob_keep = 0.7, i.e., 70% of the activations are retained\n",
    "        prob_keep = 1-drop_prob\n",
    "        \n",
    "        # Note: instead of a binary mask implement a scaled mask, where mask is scaled by dividing it \n",
    "        # by the prob_keep for example, if we have input activations of size (3,4), then the mask is \n",
    "        # mask = (np.random.rand(3,4)<prob_keep)/prob_keep\n",
    "        # We perform the scaling by prob_keep here so we don't have to do it specifically during backpropagation \n",
    "        # We then update A by multiplying it element wise with the mask\n",
    "        \n",
    "        if mode == 'train':\n",
    "            # your code here\n",
    "            mask = (np.random.rand(A.shape[0], A.shape[1])<prob_keep)/prob_keep\n",
    "            A = mask * A\n",
    "        elif mode != 'test':\n",
    "            raise ValueError(\"Mode value not set correctly, set it to 'train' or 'test'\")\n",
    "        cache = (drop_prob, mode, mask)\n",
    "        return A, cache"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "8ec618234b01b33f9d45586881a90fc5",
     "grade": true,
     "grade_id": "cell-186e9ebb0627e412",
     "locked": true,
     "points": 10,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "np.random.seed(1)\n",
    "\n",
    "x_t = np.random.rand(3,4)\n",
    "drop_prob_t = 0.3\n",
    "x_est, cache_est = dropout(x_t, drop_prob_t, mode='train')\n",
    "npt.assert_array_almost_equal(x_est,np.array(\n",
    "[[5.95745721e-01, 0.0, 1.63392596e-04, 4.31903675e-01],\n",
    " [2.09651273e-01, 1.31912278e-01, 2.66086016e-01, 4.93658181e-01],\n",
    " [0.0,            0.0,            5.98849306e-01, 9.78885001e-01]]\n",
    "),5)\n",
    "npt.assert_array_almost_equal(cache_est[2], np.array(\n",
    "[[1.42857143, 0.,         1.42857143, 1.42857143],\n",
    " [1.42857143, 1.42857143, 1.42857143, 1.42857143],\n",
    " [0.,         0.,         1.42857143, 1.42857143]]\n",
    "),5)\n",
    "assert cache_est[1]=='train'\n",
    "np.random.seed(1)\n",
    "x_t = np.random.rand(3,4)\n",
    "drop_prob_t = 0.3\n",
    "out_est, cache_est = dropout(x_t, drop_prob_t, mode='test')\n",
    "npt.assert_array_almost_equal(out_est, x_t, 6)\n",
    "assert cache_est[1]=='test'\n",
    "np.random.seed(1)\n",
    "x_t = np.random.rand(3,4)\n",
    "drop_prob_t = 0\n",
    "out_est, cache_est = dropout(x_t, drop_prob_t, mode='train')\n",
    "npt.assert_array_almost_equal(out_est, x_t, 6)\n",
    "assert cache_est[0]==0\n",
    "assert cache_est[1]=='train'\n",
    "assert cache_est[2]==None\n",
    "#hidden tests follow"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Dropout backward (10 points)\n",
    "\n",
    "In the backward pass, we estimate the derivative w.r.t. the dropout layer. We will need the 'drop_prob', 'mask' and 'mode' which is obtained from the cache saved during forward pass. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "2672cdb298d304e4a8ddf9a77a195e81",
     "grade": false,
     "grade_id": "cell-34ce98b5a9658fae",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def dropout_der(dA_in, cache):\n",
    "        '''\n",
    "        Backward pass for the inverted dropout.\n",
    "        Inputs: \n",
    "            dA_in: derivative from the upper layers of dimension (n,m).\n",
    "            cache: tuple containing (drop_out, mode, mask), where drop_out is the probability of drop_out, \n",
    "                if drop_out=0, then the layer does not have any dropout,\n",
    "                mode is either 'train' or 'test' and \n",
    "                mask is a matirx of size (n,m) where 0's indicate masked values\n",
    "        Outputs:\n",
    "            dA_out = derivative of the dropout layer of dimension (n,m)\n",
    "        '''\n",
    "        \n",
    "        dA_out = None\n",
    "        drop_out, mode, mask = cache\n",
    "        # If there is no dropout return the same derivative from the previous layer\n",
    "        if not drop_out:\n",
    "            return dA_in\n",
    "       \n",
    "        # if mode is 'train' dA_out is dA_in multiplied element wise by mask\n",
    "        # if mode is 'test' dA_out is same as dA_in\n",
    "        # your code here\n",
    "        if mode == 'train':\n",
    "            dA_out = mask * dA_in\n",
    "        elif mode == 'test':\n",
    "             dA_out = dA_in\n",
    "        elif mode != 'test':\n",
    "            raise ValueError(\"Mode value not set correctly, set it to 'train' or 'test'\")       \n",
    "            \n",
    "        return dA_out"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "4268ef2b0bc6d72e605c81879721fa9a",
     "grade": true,
     "grade_id": "cell-f8ed32ff4bf0bd9a",
     "locked": true,
     "points": 10,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "np.random.seed(1)\n",
    "dA_in_t = np.random.rand(4,2)\n",
    "mask_t = np.array(\n",
    "[[1.42857143, 1.42857143],\n",
    " [1.42857143, 1.42857143],\n",
    " [1.42857143, 0.        ],\n",
    " [1.42857143, 1.42857143]])\n",
    "mode_t = 'test'\n",
    "drop_prob_t = 0.3\n",
    "cache_t = (drop_prob_t,mode_t, mask_t)\n",
    "dA_out_est = dropout_der(dA_in_t, cache_t)\n",
    "npt.assert_array_almost_equal(dA_out_est, np.array(\n",
    "[\n",
    " [4.17022005e-01, 7.20324493e-01],\n",
    " [1.14374817e-04, 3.02332573e-01],\n",
    " [1.46755891e-01, 9.23385948e-02],\n",
    " [1.86260211e-01, 3.45560727e-01]\n",
    "]),6)\n",
    "\n",
    "mode_t = 'train'\n",
    "cache = (drop_prob_t, mode_t, mask_t)\n",
    "dA_out_est = dropout_der(dA_in_t, cache)\n",
    "npt.assert_almost_equal(dA_out_est,np.array(\n",
    "[\n",
    " [5.95745721e-01, 1.02903499e+00],\n",
    " [1.63392596e-04, 4.31903675e-01],\n",
    " [2.09651273e-01, 0.0           ],\n",
    " [2.66086016e-01, 4.93658181e-01]\n",
    "]),6)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "a23870ebbde5eeae58d49b8077aed39e",
     "grade": false,
     "grade_id": "cell-8ccc857eca28aa9d",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Batchnorm forward (15 points)\n",
    "\n",
    "Batchnorm scales the input activations in a minibatch to have a specific mean and variance allowing the training to use larger learning rates to improve training speeds and provide more stability to the training. During training, the input minibatch is first normalized by making it zero mean and scaled to unit variance, i.e., ($0,I$) normalized. The normalized data is then converted to have a mean ($\\beta$) and variance ($\\gamma$), i.e., ($\\beta,\\gamma I$) normalized. Here, $\\beta$ and $\\gamma$ are the parameters for the batchnorm layer which are updated during training using gradient descent. \n",
    "The original batchnorm paper was implemented by applying batchnorm before nonlinear activation. However, batchnorm has been found to be more effective when applied after activation. We will implement this version in Assignment 3. \n",
    "\n",
    "In the lecture, we also discussed implementation of batchnorm during test mode when a single sample may be input for evaluation. We will not be implementing this aspect of batchnorm for the assignment. This implementation will work as designed only when a minibatch of data is presented to the network during evaluation (test mode) and may not work as expected when a single image is input for evaluation (test mode). \n",
    "\n",
    "The batchnorm implementation is tricky, especially the backpropagation. You may use the following source for reference: [Batchnorm backpropagation Tutorial](https://kratzert.github.io/2016/02/12/understanding-the-gradient-flow-through-the-batch-normalization-layer.html). Note: The tutorial representes data as a $(m,n)$ matrix, whereas we represent data as a $(n,m)$ matrix, where $n$ is feature dimensions and $m$ is number of samples. \n",
    "\n",
    "If you are unable to implement the batchnorm correctly, you can still get the network to work by setting the variable 'bnorm_list = [0,0,...,0,0]. This is a list of binary varibles indicating if batchnorm is used for a layer (0 means no batchorm for the corresponding layer). This variable is used in the 'multi_layer_network(.)' function when initalizing the network. \n",
    "Although the follwing testcases may fail, the network can still work without batchnorm and you can get partial credit. \n",
    "\n",
    "The variables you save into the cache is your choice. The tescase only tests for the normalized output."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "9bc0845e4a2333e69c031fe554c4e921",
     "grade": false,
     "grade_id": "batchnorm_forward_soln",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def batchnorm(A, beta, gamma):\n",
    "    '''\n",
    "    Batchnorm normalizes the input A to mean beta and standard deviation gamma\n",
    "    \n",
    "    Inputs: \n",
    "        A: Activation input after activation - shape is (n,m), m samples where each sample x is (n,1)\n",
    "        beta: mean vector which will be the center of the data after batchnorm - shape is (n,1)\n",
    "        gamma: standard deviation vector which will be scale of the data after batchnorm - shape (n,1)\n",
    "        \n",
    "    Outputs: \n",
    "        Anorm: Normalized version of input A - shape (n,m)\n",
    "        cache: Dictionary of the elements that are necessary for backpropagation\n",
    "    '''\n",
    "    \n",
    "    # When there is no batch norm for a layer, the beta and gamma will be empty arrays\n",
    "    if beta.size == 0 or gamma.size == 0:\n",
    "        cache = {}\n",
    "        return A, cache\n",
    "    # epsilon value used for scaling during normalization to avoid divide by zero. \n",
    "    # don't change this value - the test case will fail if you change this value\n",
    "    epsilon = 1e-5\n",
    "    # your code here\n",
    "    n = A.shape[0]\n",
    "    m = A.shape[1]\n",
    "    mean = np.mean(A, axis=1, keepdims=True)\n",
    "    variance = np.mean(np.power(A-mean, 2), axis=1, keepdims=True)\n",
    "    A_hat = np.copy(A)\n",
    "    Anorm = np.copy(A) \n",
    "    mean_diff = np.copy(A)\n",
    "    cache = {}\n",
    "    n = A.shape[0]\n",
    "    for row in range(A.shape[0]):\n",
    "        mean_diff[row,:] = A[row,:] - mean[row]\n",
    "        A_hat[row,:]= mean_diff[row,:]/np.sqrt(variance[row] + epsilon)\n",
    "        Anorm[row,:]= gamma[row] * A_hat[row,:] + beta[row]\n",
    "    \n",
    "    cache = (mean, variance, beta, gamma, epsilon, A_hat, Anorm, mean_diff)\n",
    "    return Anorm, cache"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "7b455a20620ddc1f598a35bf733a004b",
     "grade": true,
     "grade_id": "batchnorm_forward",
     "locked": true,
     "points": 15,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "A_t = np.array([[1., 2.],[3., 4.],[5., 6]])\n",
    "beta_t = np.array([[1.], [2.], [3.]])\n",
    "gamma_t = np.array([[4.], [5.], [6.]])\n",
    "Anorm_est, cache_est = batchnorm(A_t, beta_t, gamma_t)\n",
    "npt.assert_array_almost_equal(Anorm_est,np.array(\n",
    "[\n",
    " [-2.99992,  4.99992],\n",
    " [-2.9999,   6.9999 ],\n",
    " [-2.99988,  8.99988]\n",
    "]),5)\n",
    "\n",
    "# There are hidden tests"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "235204f5e72f927c473528f0a1155a10",
     "grade": false,
     "grade_id": "cell-a8cf50ba49b92a32",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Batchnorm backward (15 points)\n",
    "\n",
    "The forward propagation for batchnorm is relatively straightfoward to implement. For the backward propagation to worrk, you will need to save a set of variables in the cache during the forward propagation. The variables in your cache are your choice. The testcase only tests for the derivative."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "fb73a49523de475c649d69105c08ceac",
     "grade": false,
     "grade_id": "batchnorm_backward_soln",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def batchnorm_der(dA_in, cache):\n",
    "    '''\n",
    "    Derivative of the batchnorm\n",
    "    Inputs: \n",
    "        dA_in: derivative from the upper layers of dimension (n,m).\n",
    "        cache: Dictionary of the elements that are necessary for backpropagation\n",
    "    Outputs:\n",
    "        dA_out: derivative of the batchnorm layer of dimension (n,m)\n",
    "        dbeta: derivative of beta - shape (n,1)\n",
    "        dgamma: derivative of gamma - shape (n,1)\n",
    "    '''\n",
    "    # When the cache is empty, it indicates there was no batchnorm for the layer\n",
    "    if not cache:\n",
    "        dbeta = []\n",
    "        dgamma = []\n",
    "        return dA_in, dbeta, dgamma\n",
    "    \n",
    "    # your code here\n",
    "    mean, variance, beta, gamma, epsilon, A_hat, Anorm, mean_diff = cache \n",
    "    \n",
    "    N,M = dA_in.shape\n",
    "    \n",
    "    dgamma = np.sum(dA_in * A_hat, axis=1)\n",
    "    dgamma.resize(dgamma.size, 1)\n",
    "    \n",
    "    dbeta = np.sum(dA_in, axis=1)\n",
    "    dbeta.resize(dbeta.size, 1)\n",
    "    \n",
    "    sqrt_var = np.sqrt(variance + epsilon)\n",
    "    sqrt_var.resize(sqrt_var.size, 1)\n",
    "    \n",
    "    inv_var = 1. /sqrt_var\n",
    "    inv_var.resize(inv_var.size, 1)\n",
    "    \n",
    "    dx_hat = dA_in * gamma\n",
    "    \n",
    "    dA_out = np.copy(dA_in)\n",
    "\n",
    "    sum1 = np.sum(dx_hat, axis=1) \n",
    "    sum1.resize(sum1.size, 1)\n",
    "    \n",
    "    sum2 = np.sum(dx_hat*A_hat, axis=1)\n",
    "    sum2.resize(sum2.size, 1)\n",
    "    \n",
    "    dA_out = (1. / M) * inv_var * (M*dx_hat - sum1 - A_hat * sum2)\n",
    "\n",
    "    return dA_out, dbeta, dgamma"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "0af813c4cdf435717076d9fc55d03e5e",
     "grade": true,
     "grade_id": "batchnorm_backward",
     "locked": true,
     "points": 15,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "A_t = np.array([[1., 2.],[3., 4.],[5., 6]])\n",
    "beta_t = np.array([[1.], [2.], [3.]])\n",
    "gamma_t = np.array([[4.], [5.], [6.]])\n",
    "Anorm_t, cache_t = batchnorm(A_t, beta_t, gamma_t)\n",
    "dA_in_t = np.array(\n",
    "[\n",
    "  [4.,  5.],\n",
    "  [8.,  10.],\n",
    "  [12., 15.]\n",
    "])\n",
    "dA_out_est, dbeta_est, dgamma_est = batchnorm_der(dA_in_t, cache_t)\n",
    "npt.assert_array_almost_equal(dA_out_est,np.array(\n",
    "[\n",
    " [ -0.0001600,    0.0001600],\n",
    " [ -0.0004000,    0.0004000],\n",
    " [ -0.0007200,    0.0007200]\n",
    "]),5)\n",
    "npt.assert_array_almost_equal(dbeta_est,np.array([[9.],[18.],[27.]]),5)\n",
    "npt.assert_array_almost_equal(dgamma_est,np.array([[1.],[2.],[3.]]),4)\n",
    "\n",
    "# There are hidden tests"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "2afffb84ecba8a8f56c26aece3a4998c",
     "grade": false,
     "grade_id": "cell-2d445d2fe1bb530d",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Parameter Initialization (5 points)\n",
    "\n",
    "We will define the function to initialize the parameters of the multi-layer neural network.\n",
    "The network parameters will be stored as dictionary elements that can easily be passed as function parameters while calculating gradients during back propogation.\n",
    "\n",
    "The parameters are initialized using Kaiming He Initialization (discussed in the lecture). For example, a layer with weights of dimensions $(n_{out}, n_{in})$, the parameters are initialized as\n",
    "$w = np.random.randn(n_{out},n_{in})*(2./np.sqrt(n_{in}))$ and \n",
    "$b = np.zeros((n_{out},1))$\n",
    "\n",
    "The dimension for weight matrix for layer $(l+1)$ is given by ( Number-of-neurons-in-layer-$(l+1)$   $\\times$   Number-of-neurons-in-layer-$l$ ). The dimension of the bias for for layer $(l+1)$ is (Number-of-neurons-in-layer-$(l+1)$   $\\times$   1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "5776d8f512e36381fef5991f897725c0",
     "grade": false,
     "grade_id": "params_initialize_soln",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def initialize_network(net_dims, act_list, drop_prob_list):\n",
    "    '''\n",
    "    Initializes the parameters W's and b's of a multi-layer neural network\n",
    "    Adds information about dropout and activations in each layer\n",
    "    \n",
    "    Inputs:\n",
    "        net_dims: List containing the dimensions of the network. The values of the array represent the number of nodes in \n",
    "        each layer. For Example, if a Neural network contains 784 nodes in the input layer, 800 in the first hidden layer, \n",
    "        500 in the secound hidden layer and 10 in the output layer, then net_dims = [784,800,500,10]. \n",
    "        act_list: list of strings indicating the activation for a layer\n",
    "        drop_prob_list: list of dropout probabilities for each layer \n",
    "    \n",
    "    Outputs:\n",
    "        parameters: dictionary of \n",
    "                    {\"numLayers\":..}\n",
    "                    activations, {\"act1\":\"..\", \"act2\":\"..\", ...}\n",
    "                    dropouts, {\"dropout1\": .. , \"dropout2\": .., ...}\n",
    "                    network parameters, {\"W1\":[..],\"b1\":[..],\"W2\":[..],\"b2\":[..],...}\n",
    "            The weights are initialized using Kaiming He et al. Initialization\n",
    "    '''\n",
    "    net_dims_len = len(net_dims)\n",
    "    parameters = {}\n",
    "    parameters['numLayers'] = net_dims_len - 1;\n",
    "    for l in range(net_dims_len-1):\n",
    "        parameters[\"act\"+str(l+1)] = act_list[l]\n",
    "        parameters[\"dropout\"+str(l+1)] = drop_prob_list[l]\n",
    "        # Note: Use He et al. Initialization to initialize W and set bias to 0's\n",
    "        # parameters[\"W\"+str(l+1)] = \n",
    "        # parameters[\"b\"+str(l+1)] =\n",
    "        # your code here\n",
    "        \n",
    "        parameters[\"W\"+str(l+1)] = np.random.randn(net_dims[l+1], net_dims[l]) * 2./np.sqrt(net_dims[l])\n",
    "        parameters[\"b\"+str(l+1)] = np.zeros((net_dims[l+1], 1))\n",
    "        \n",
    "    return parameters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "94e0b6b2c740ec0a066d1d5b06937bfd",
     "grade": true,
     "grade_id": "params_initialize",
     "locked": true,
     "points": 5,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "#Test \n",
    "np.random.seed(1)\n",
    "net_dims_t = [3,4,1]\n",
    "act_list_t = ['relu', 'linear']\n",
    "drop_prob_list = [0.3,0.5]\n",
    "parameters_est = initialize_network(net_dims_t, act_list_t, drop_prob_list)\n",
    "npt.assert_array_almost_equal(parameters_est['W1'], [\n",
    " [ 1.87563247, -0.70639546, -0.60988021],\n",
    " [-1.23895745,  0.99928666, -2.65758797],\n",
    " [ 2.01473508, -0.87896602,  0.36839462],\n",
    " [-0.28794811,  1.68829682, -2.37884559]\n",
    "],6)\n",
    "assert parameters_est['W1'].shape == (4,3)\n",
    "assert parameters_est['W2'].shape == (1,4)\n",
    "assert parameters_est['b1'].shape == (4,1)\n",
    "assert parameters_est['b2'].shape == (1,1)\n",
    "assert parameters_est['b1'].all() == 0\n",
    "assert parameters_est['b2'].all() == 0\n",
    "assert parameters_est['act1'] == 'relu'\n",
    "assert parameters_est['act2'] == 'linear'\n",
    "assert parameters_est['dropout1'] == 0.3\n",
    "assert parameters_est['dropout2'] == 0.5\n",
    "# There are hidden tests"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "e02e8f835aa4d3015ff23b01f6fc4a1e",
     "grade": false,
     "grade_id": "cell-ffe90db2e8c100f5",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Adam (momentum) Parameters - Velocity and Gradient-Squares Initialization (5 points)\n",
    "\n",
    "We will optmize using Adam (momentum). This requires velocity parameters $V$ and Gradient-Squares parameters $G$. Here is a quick recap of Adam optmization, \n",
    "\n",
    "\\begin{equation} \n",
    "V_{t+1} = \\beta V_{t} +(1-\\beta)\\nabla J(\\theta_t)\\\\ \n",
    "G_{t+1} = \\beta_2 G_{t} +(1-\\beta_2)\\nabla J(\\theta_t)^2\\\\ \n",
    "\\theta_{t+1} =\\theta_{t} -\\frac{\\alpha}{\\sqrt{G_{t+1}+\\epsilon}}V_{t+1}, \\quad \\theta \\in \\{ W,b \\} \n",
    "\\end{equation}\n",
    "\n",
    "Parameters $V$ are the momentum velocity parameters and parameters $G$ are the Gradient-Squares. \n",
    "$\\nabla J(\\theta)$ is the gradient term $dW$ or $db$, and $\\nabla  J(\\theta)^2$ is the element wise square of the gradient. \n",
    "$\\alpha$ is the step_size for gradient descent. It is has been estimated by decaying the 'learning_rate' based on 'decay_rat'e and 'epoch' number. $\\beta$, $\\beta_2$ and $\\epsilon$ are constants which we will set up later.\n",
    "\n",
    "Each of the parameters $W$'s and $b$'s for all the layers will have their corresponding velocity ($V$) and Gradient-Squares ($G$) parameters. The following function will initialize $V$ and $G$ to zeros with the same size as the corresponding parameters. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "e57ee4eb4685673bb0629cc87fcf2475",
     "grade": false,
     "grade_id": "cell-dd58518f843ee3ec",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def initialize_velocity(parameters, apply_momentum=True):\n",
    "    '''\n",
    "    The function will add Adam momentum parameters, Velocity and Gradient-Squares \n",
    "    to the parameters for each of the W's and b's \n",
    "    \n",
    "    Inputs: \n",
    "        parameters: dictionary containing, \n",
    "                    {\"numLayers\":..}\n",
    "                    activations, {\"act1\":\"..\", \"act2\":\"..\", ...}\n",
    "                    dropouts, {\"dropout1\": .. , \"dropout2\": .., ...}\n",
    "                    network parameters, {\"W1\":[..],\"b1\":[..],\"W2\":[..],\"b2\":[..],...}\n",
    "                    Note: It is just one dictionary (parameters) with all these key value pairs, not multiple dictionaries\n",
    "        apply_momentum: boolean on whether to apply momentum\n",
    "        \n",
    "    Outputs:\n",
    "        parameters: dictionary that has been updated to include velocity and Gradient-Squares. It now contains,\n",
    "                    {\"numLayers\":..}\n",
    "                    activations, {\"act1\":\"..\", \"act2\":\"..\", ...}\n",
    "                    dropouts, {\"dropout1\": .. , \"dropout2\": .., ...}\n",
    "                    {\"apply_momentum\":..}\n",
    "                    velocity parameters, {\"VdW1\":[..],\"Vdb1\":[..],\"VdW2\":[..],\"Vdb2\":[..],...}\n",
    "                    Gradient-Squares parameters, {\"GdW1\":[..],\"Gdb1\":[..],\"GdW2\":[..],\"Gdb2\":[..],...}\n",
    "                    Note: It is just one dictionary (parameters) with all these key value pairs, not multiple dictionaries\n",
    "    '''\n",
    "    \n",
    "    L = parameters['numLayers'] \n",
    "    parameters['apply_momentum'] = apply_momentum\n",
    "    \n",
    "    # Initialize Velocity and the Gradient-Squares to zeros the same size as the corresponding parameters W's abd b's\n",
    "    for l in range(L):\n",
    "        if apply_momentum:\n",
    "            # Hint: Velocity parameters are represented as VdW and Vdb\n",
    "            #      Gradient-Squares are represented as GdW and Gdb\n",
    "            # You can use np.zeros_like(.) to initilaize them 0's the same size as corresponding parameters W and b\n",
    "            # parameters[\"VdW\" + str(l+1)] = \n",
    "            # parameters[\"Vdb\" + str(l+1)] =\n",
    "            # parameters[\"GdW\" + str(l+1)] =\n",
    "            # parameters[\"Gdb\" + str(l+1)] =\n",
    "            # your code here\n",
    "            parameters[\"VdW\" + str(l+1)] = np.zeros_like(parameters[\"W\" + str(l+1)])\n",
    "            parameters[\"Vdb\" + str(l+1)] = np.zeros_like(parameters[\"b\" + str(l+1)])\n",
    "            parameters[\"GdW\" + str(l+1)] = np.zeros_like(parameters[\"W\" + str(l+1)])\n",
    "            parameters[\"Gdb\" + str(l+1)] = np.zeros_like(parameters[\"b\" + str(l+1)])\n",
    "            \n",
    "    return parameters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "10c8698ec51d04aec1f7901ea186c98f",
     "grade": true,
     "grade_id": "cell-5346e9cc7d26c1e3",
     "locked": true,
     "points": 5,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "#Test \n",
    "net_dims_t = [5,4,1]\n",
    "act_list_t = ['relu', 'linear']\n",
    "drop_prob_list = [0.3,0.5]\n",
    "parameters_t = initialize_network(net_dims_t, act_list_t, drop_prob_list)\n",
    "parameters_t = initialize_velocity(parameters_t)\n",
    "assert parameters_t['VdW1'].shape == (4,5)\n",
    "assert parameters_t['VdW1'].all() == 0\n",
    "assert parameters_t['VdW2'].shape == (1,4)\n",
    "assert parameters_t['VdW2'].all() == 0\n",
    "assert parameters_t['Vdb1'].shape == (4,1)\n",
    "assert parameters_t['Vdb2'].shape == (1,1) \n",
    "assert parameters_t['Vdb1'].all() == 0\n",
    "assert parameters_t['Vdb2'].all() == 0\n",
    "assert parameters_t['GdW1'].shape == (4,5)\n",
    "assert parameters_t['GdW1'].all() == 0\n",
    "assert parameters_t['GdW2'].shape == (1,4)\n",
    "assert parameters_t['GdW2'].all() == 0\n",
    "assert parameters_t['Gdb1'].shape == (4,1)\n",
    "assert parameters_t['Gdb2'].shape == (1,1)\n",
    "assert parameters_t['Gdb1'].all() == 0\n",
    "assert parameters_t['Gdb2'].all() == 0\n",
    "assert parameters_t['apply_momentum'] == True\n",
    "# There are hidden tests"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "372ead70fa94bbbb5eefe274e3222488",
     "grade": false,
     "grade_id": "cell-e8ad576b87cea2fb",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Batchnorm Parameters and corresponding Velocity and Gradient-Squares Initialization "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "a6f2e5619b0754c69df03c22395830cd",
     "grade": false,
     "grade_id": "cell-74f99853a41130d6",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def initialize_bnorm_params(parameters, bnorm_list, apply_momentum):\n",
    "    '''\n",
    "    The function will add batchnorm parameters beta's and gamma's and their corresponding\n",
    "    Velocity and Gradient-Squares to the parameters dictionary\n",
    "    \n",
    "    Inputs: \n",
    "        parameters: dictionary that contains,\n",
    "                    {\"numLayers\":..}\n",
    "                    activations, {\"act1\":\"..\", \"act2\":\"..\", ...}\n",
    "                    dropouts, {\"dropout1\": .. , \"dropout2\": .., ...}\n",
    "                    {\"apply_momentum\":..}\n",
    "                    velocity parameters, {\"VdW1\":[..],\"Vdb1\":[..],\"VdW2\":[..],\"Vdb2\":[..],...}\n",
    "                    Gradient-Squares parameters, {\"GdW1\":[..],\"Gdb1\":[..],\"GdW2\":[..],\"Gdb2\":[..],...}\n",
    "                    Note: It is just one dictionary (parameters) with all these key value pairs, not multiple dictionaries\n",
    "        bnorm_list: binary list indicating if batchnorm should be implemented for a layer\n",
    "        apply_momentum: boolean on whether to apply momentum\n",
    "        \n",
    "    Outputs:\n",
    "        parameters: dictionary that has been updated to include batchnorm parameters, beta, gamma \n",
    "                    and their corresponding momentum parameters. It now contains,\n",
    "                    {\"numLayers\":..}\n",
    "                    activations, {\"act1\":\"..\", \"act2\":\"..\", ...}\n",
    "                    dropouts, {\"dropout1\": .. , \"dropout2\": .., ...}\n",
    "                    velocity parameters, {\"VdW1\":[..],\"Vdb1\":[..],\"VdW2\":[..],\"Vdb2\":[..],...}\n",
    "                    Gradient-Squares parameters, {\"GdW1\":[..],\"Gdb1\":[..],\"GdW2\":[..],\"Gdb2\":[..],...}\n",
    "                    {\"bnorm_list\":..}\n",
    "                    batchnorm parameters, {\"bnorm_beta1\":[..],\"bnorm_gamma1\":[..],\"bnorm_beta2\":[..],\"bnorm_gamma2\":[..],...}\n",
    "                    batchnorm velocity parameters, {\"Vbnorm_beta1\":[..],\"Vbnorm_gamma1\":[..],\"Vbnorm_beta2\":[..],\"Vbnorm_gamma2\":[..],...}\n",
    "                    batchnorm Gradient-Square parameters, {\"Gbnorm_beta1\":[..],\"Gbnorm_gamma1\":[..],\"Gbnorm_beta2\":[..],\"Gbnorm_gamma2\":[..],...}\n",
    "                    Note: It is just one dictionary (parameters) with all these key value pairs, not multiple dictionaries\n",
    "    '''\n",
    "    \n",
    "    L = parameters['numLayers']\n",
    "    parameters['bnorm_list'] = bnorm_list\n",
    "    \n",
    "    # Initialize batchnorm parameters for the hidden layers only. \n",
    "    # Each hidden layer will have a dictionary of parameters, beta and gamma based on the dimensions of the hidden layer. \n",
    "    for l in range(L):\n",
    "        if bnorm_list[l]:\n",
    "            n = parameters[\"W\" + str(l+1)].shape[0]\n",
    "            parameters['bnorm_beta'+str(l+1)] = np.random.randn(n,1)\n",
    "            parameters['bnorm_gamma'+str(l+1)] = np.random.randn(n,1)\n",
    "            if apply_momentum:\n",
    "                parameters['Vbnorm_beta'+str(l+1)] = np.zeros((n,1))\n",
    "                parameters['Gbnorm_beta'+str(l+1)] = np.zeros((n,1))\n",
    "                parameters['Vbnorm_gamma'+str(l+1)] = np.zeros((n,1))\n",
    "                parameters['Gbnorm_gamma'+str(l+1)] = np.zeros((n,1))\n",
    "        else:\n",
    "            parameters['bnorm_beta'+str(l+1)] = np.asarray([])\n",
    "            parameters['Vbnorm_beta'+str(l+1)] = np.asarray([])\n",
    "            parameters['Gbnorm_beta'+str(l+1)] = np.asarray([])\n",
    "            parameters['bnorm_gamma'+str(l+1)] = np.asarray([])\n",
    "            parameters['Vbnorm_gamma'+str(l+1)] = np.asarray([])\n",
    "            parameters['Gbnorm_gamma'+str(l+1)] = np.asarray([])\n",
    "    return parameters"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "ba2dbfdf3f3b183229914f723e1417d7",
     "grade": false,
     "grade_id": "cell-36236b2868ecda30",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Forward Propagation Through a Single Layer (repeated from Assignment 2 - 0 points)\n",
    "\n",
    "If the vectorized input to any layer of neural network is $A\\_prev$ and the parameters of the layer are given by $(W,b)$, the output of the layer (before the activation is):\n",
    "\\begin{equation}\n",
    "Z = W.A\\_prev + b\n",
    "\\end{equation}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "ed4865aef2f388d832326ef6c4160c95",
     "grade": false,
     "grade_id": "forward_single_layer_soln",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def linear_forward(A_prev, W, b):\n",
    "    '''\n",
    "    Input A_prev propagates through the layer \n",
    "    Z = WA + b is the output of this layer. \n",
    "\n",
    "    Inputs: \n",
    "        A_prev: numpy.ndarray (n,m) the input to the layer\n",
    "        W: numpy.ndarray (n_out, n) the weights of the layer\n",
    "        b: numpy.ndarray (n_out, 1) the bias of the layer\n",
    "\n",
    "    Outputs:\n",
    "        Z: where Z = W.A_prev + b, where Z is the numpy.ndarray (n_out, m) dimensions\n",
    "        cache: a dictionary containing the inputs A\n",
    "    '''\n",
    "    # your code here\n",
    "    Z = np.dot(W, A_prev) + b\n",
    "\n",
    "    cache = {}\n",
    "    cache[\"A\"] = A_prev\n",
    "    return Z, cache"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "ff99bfd982a9c8c02c5df742e8a1c251",
     "grade": true,
     "grade_id": "forward_single_layer",
     "locked": true,
     "points": 0,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "#Hidden test cases follow\n",
    "np.random.seed(1)\n",
    "n1 = 3\n",
    "m1 = 4\n",
    "A_prev_t = np.random.randn(n1,m1)\n",
    "W_t = np.random.randn(n1, n1)\n",
    "b_t = np.random.randn(n1, 1)\n",
    "Z_est, cache_est = linear_forward(A_prev_t, W_t, b_t)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "a78556ac91473852bcf96924e78854ad",
     "grade": false,
     "grade_id": "cell-3c463f4362ff9844",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Forward Propagation Through a Layer (linear $\\rightarrow$ activation $\\rightarrow$ batchnorm $\\rightarrow$ dropout)\n",
    "\n",
    "The input to the layer propagates through the layer in the order linear $\\rightarrow$ activation $\\rightarrow$ batchnorm $\\rightarrow$ dropout saving different cache along the way."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "07631dfdb8eefbc842508a3536dffaaa",
     "grade": false,
     "grade_id": "cell-f70a31ac49d9bb4c",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def layer_forward(A_prev, W, b, activation, drop_prob, bnorm_beta, bnorm_gamma, mode):\n",
    "    '''\n",
    "    Input A_prev propagates through the layer followed by activation, batchnorm and dropout\n",
    "\n",
    "    Inputs: \n",
    "        A_prev: numpy.ndarray (n,m) the input to the layer\n",
    "        W: numpy.ndarray (n_out, n) the weights of the layer\n",
    "        b: numpy.ndarray (n_out, 1) the bias of the layer\n",
    "        activation: is the string that specifies the activation function\n",
    "        drop_prob: dropout parameter. If drop_prob = 0.3, we drop 30% of the neuron activations\n",
    "        bnorm_beta: batchnorm beta \n",
    "        bnorm_gamma: batchnorm gamma\n",
    "        mode: 'train' or 'test' Dropout acts differently in training and testing mode. Hence, mode is a parameter which\n",
    "                takes in only 2 values, 'train' or 'test'\n",
    "\n",
    "    Outputs:\n",
    "        A: = g(Z), where Z = WA + b, where Z is the numpy.ndarray (n_out, m) dimensions\n",
    "        g is the activation function\n",
    "        cache: a dictionary containing the cache from the linear propagation, activation, bacthnorm and dropout\n",
    "        to be used for derivative\n",
    "    '''\n",
    "    \n",
    "    Z, lin_cache = linear_forward(A_prev, W, b)\n",
    "    if activation == \"relu\":\n",
    "        A, act_cache = relu(Z)\n",
    "    elif activation == \"linear\":\n",
    "        A, act_cache = linear(Z)\n",
    "    \n",
    "    A, bnorm_cache = batchnorm(A, bnorm_beta, bnorm_gamma)\n",
    "    A, drop_cache = dropout(A, drop_prob, mode)\n",
    "    cache = {}\n",
    "    cache[\"lin_cache\"] = lin_cache\n",
    "    cache[\"act_cache\"] = act_cache\n",
    "    cache[\"bnorm_cache\"] = bnorm_cache\n",
    "    cache[\"drop_cache\"] = drop_cache\n",
    "    \n",
    "    return A, cache"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "611df0adfac42ead393f088d11e8826e",
     "grade": false,
     "grade_id": "cell-243ec2c02ff1834c",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Multi-Layers Forward Propagation\n",
    "\n",
    "Starting with the input 'A0' and the first layer of the network, we will propgate A0 through every layer using the output of the previous layer as input to the next layer. we will gather the caches from every layer in a list and use it later for backpropagation. We will use the 'layer_forward(.)' function to get the output and caches for a layer. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "dd87521073a2f0a0c07338d938566eb7",
     "grade": false,
     "grade_id": "cell-40ada61852849730",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def multi_layer_forward(A0, parameters, mode):\n",
    "    '''\n",
    "    Forward propgation through the layers of the network\n",
    "\n",
    "    Inputs: \n",
    "        A0: numpy.ndarray (n,m) with n features and m samples\n",
    "        parameters: dictionary of network parameters {\"W1\":[..],\"b1\":[..],\"W2\":[..],\"b2\":[..]...}\n",
    "        mode: 'train' or 'test' Dropout acts differently in training and testing mode. Hence, mode is a parameter which\n",
    "                takes in only 2 values, 'train' or 'test' \n",
    "    \n",
    "    Outputs:\n",
    "        AL: numpy.ndarray (c,m)  - outputs of the last fully connected layer before softmax\n",
    "            where c is number of categories and m is number of samples\n",
    "        caches: a list of caches from every layer after forward propagation\n",
    "    '''\n",
    "    \n",
    "    L = parameters['numLayers']\n",
    "    A = A0\n",
    "    caches = []\n",
    "    for l in range(L):\n",
    "        A, cache = layer_forward(A, parameters[\"W\"+str(l+1)], parameters[\"b\"+str(l+1)], \\\n",
    "                                 parameters[\"act\"+str(l+1)], parameters[\"dropout\"+str(l+1)], \\\n",
    "                                 parameters['bnorm_beta'+str(l+1)], parameters['bnorm_gamma'+str(l+1)], mode)\n",
    "        caches.append(cache)\n",
    "    return A, caches"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "136f3914445b836e7df4bba3238ce216",
     "grade": false,
     "grade_id": "cell-5281900868c84d39",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Backward Propagagtion for the Linear Computation of a Layer (repeated from Assignment 2 - 0 points)\n",
    "\n",
    "Consider the linear layer $Z = W.A\\_prev + b$. We would like to estimate the gradients $\\frac{dL}{dW}$ - represented as $dW$, $\\frac{dL}{db}$ - represented as $db$ and $\\frac{dL}{dA\\_prev}$ - represented as $dA\\_prev$. \n",
    "The input to estimate these derivatives is $\\frac{dL}{dZ}$ - represented as $dZ$. The derivatives are given by, \n",
    "\n",
    "\\begin{equation}\n",
    "dA\\_prev = W^T dZ\\\\\n",
    "dW = dZ A^T\\\\\n",
    "db = \\sum_{i=1}^{m} dZ^{(i)}\\\\\n",
    "\\end{equation}\n",
    "\n",
    "where $dZ = [dz^{(1)},dz^{(2)}, \\ldots, dz^{(m)}]$ is $(n \\times m)$ matrix of derivatives. \n",
    "The figure below represents a case fo binary cassification where $dZ$ is of dimensions $(1 \\times m)$. The example can be extended to $(n\\times m)$. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "cf41a82263726e6035c2585266317b26",
     "grade": false,
     "grade_id": "linear_backward_soln",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def linear_backward(dZ, cache, W, b):\n",
    "    '''\n",
    "    Backward prpagation through the linear layer\n",
    "\n",
    "    Inputs:\n",
    "        dZ: numpy.ndarray (n,m) derivative dL/dz \n",
    "        cache: a dictionary containing the inputs A, for the linear layer\n",
    "            where Z = WA + b,    \n",
    "            Z is (n,m); W is (n,p); A is (p,m); b is (n,1)\n",
    "        W: numpy.ndarray (n,p)\n",
    "        b: numpy.ndarray (n,1)\n",
    "\n",
    "    Outputs:\n",
    "        dA_prev: numpy.ndarray (p,m) the derivative to the previous layer\n",
    "        dW: numpy.ndarray (n,p) the gradient of W \n",
    "        db: numpy.ndarray (n,1) the gradient of b\n",
    "    '''\n",
    "    \n",
    "    A = cache[\"A\"]\n",
    "    # your code here\n",
    "    dA_prev = np.dot(np.transpose(W), dZ)\n",
    "    dW = np.dot(dZ, np.transpose(A))\n",
    "    db = np.sum(dZ, axis=1, keepdims=True)\n",
    "    return dA_prev, dW, db"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "d739ea390f5d7e02b6798ce19d59dabc",
     "grade": true,
     "grade_id": "linear_backward",
     "locked": true,
     "points": 0,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "#Hidden test cases follow\n",
    "np.random.seed(1)\n",
    "n1 = 3\n",
    "m1 = 4\n",
    "p1 = 5\n",
    "dZ_t = np.random.randn(n1,m1)\n",
    "A_t = np.random.randn(p1,m1)\n",
    "cache_t = {}\n",
    "cache_t['A'] = A_t\n",
    "W_t = np.random.randn(n1,p1)\n",
    "b_t = np.random.randn(n1,1)\n",
    "\n",
    "dA_prev_est, dW_est, db_est = linear_backward(dZ_t, cache_t, W_t, b_t)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "2e7ae2a750bd9690d211025d37278304",
     "grade": false,
     "grade_id": "cell-f57dc4108dd56c38",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Back Propagation Through a Layer (dropout $\\rightarrow$ batchnorm $\\rightarrow$ activation $\\rightarrow$ linear)\n",
    "\n",
    "We will define the backpropagation for a layer. We will use the backpropagation for the dropout, followed by backpropagation for batchnorm, backpropagation of activation and backpropagation of a linear layer, in that order. This is the reverse order to the forward propagation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "21b514c5a427c236a4954e4465ad2fc4",
     "grade": false,
     "grade_id": "cell-9b7cfa89255f3e03",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def layer_backward(dA, cache, W, b, activation):\n",
    "    '''\n",
    "    Backward propagation through the activation and linear layer\n",
    "\n",
    "    Inputs:\n",
    "        dA: numpy.ndarray (n,m) the derivative to the previous layer\n",
    "        cache: dictionary containing the linear_cache and the activation_cache\n",
    "        W: numpy.ndarray (n,p)\n",
    "        b: numpy.ndarray (n,1)\n",
    "        activation: activation of the layer, 'relu' or 'linear'\n",
    "    \n",
    "    Outputs:\n",
    "        dA_prev: numpy.ndarray (p,m) the derivative to the previous layer\n",
    "        dW: numpy.ndarray (n,p) the gradient of W \n",
    "        db: numpy.ndarray (n,1) the gradient of b\n",
    "        dbnorm_beta: numpy.ndarray (n,1) derivative of beta for the batchnorm layer\n",
    "        dbnorm_gamma: numpy.ndarray (n,1) derivative of gamma for the batchnorm layer\n",
    "    '''\n",
    "\n",
    "    lin_cache = cache[\"lin_cache\"]\n",
    "    act_cache = cache[\"act_cache\"]\n",
    "    drop_cache = cache[\"drop_cache\"]\n",
    "    bnorm_cache = cache[\"bnorm_cache\"]\n",
    "    \n",
    "    dA = dropout_der(dA, drop_cache)\n",
    "    dA, dbnorm_beta, dbnorm_gamma = batchnorm_der(dA, cache[\"bnorm_cache\"])\n",
    "    if activation == \"relu\":\n",
    "        dZ = relu_der(dA, act_cache)\n",
    "    elif activation == \"linear\":\n",
    "        dZ = linear_der(dA, act_cache)\n",
    "        \n",
    "    dA_prev, dW, db = linear_backward(dZ, lin_cache, W, b)\n",
    "    return dA_prev, dW, db, dbnorm_beta, dbnorm_gamma"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "63dd4a8b2ce39e28960758bcc6393bfc",
     "grade": false,
     "grade_id": "cell-72a9dc0cb265dc90",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Multi-layers Back Propagation\n",
    "\n",
    "We have defined the required functions to handle back propagation for a single layer. Now we will stack the layers together and perform back propagation on the entire network starting with the final layer. We will need teh caches stored during forward propagation. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "b3c530dd1f62e5cee0dc1c3626ab8832",
     "grade": false,
     "grade_id": "cell-8d2141e7c67dafa5",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def multi_layer_backward(dAL, caches, parameters):\n",
    "    '''\n",
    "    Back propgation through the layers of the network (except softmax cross entropy)\n",
    "    softmax_cross_entropy can be handled separately\n",
    "\n",
    "    Inputs: \n",
    "        dAL: numpy.ndarray (n,m) derivatives from the softmax_cross_entropy layer\n",
    "        caches: a dictionary of associated caches of parameters and network inputs\n",
    "        parameters: dictionary of network parameters {\"W1\":[..],\"b1\":[..],\"W2\":[..],\"b2\":[..]...}\n",
    "\n",
    "    Outputs:\n",
    "        gradients: dictionary of gradient of network parameters \n",
    "            {\"dW1\":[..],\"db1\":[..],\"dW2\":[..],\"db2\":[..],...\\\n",
    "            \"dbnorm_beta1\":[..],\"dbnorm_gamma1\":[..],\"dbnorm_beta2\":[..],\"dbnorm_gamma2\":[..],...}\n",
    "    '''\n",
    "\n",
    "    L = len(caches) \n",
    "    gradients = {}\n",
    "    dA = dAL\n",
    "    activation = \"linear\"\n",
    "    for l in reversed(range(L)):\n",
    "        dA, gradients[\"dW\"+str(l+1)], gradients[\"db\"+str(l+1)], \\\n",
    "        gradients[\"dbnorm_beta\"+str(l+1)], gradients[\"dbnorm_gamma\"+str(l+1)] \\\n",
    "                    = layer_backward(dA, caches[l], parameters[\"W\"+str(l+1)],\\\n",
    "                                     parameters[\"b\"+str(l+1)],parameters[\"act\"+str(l+1)])\n",
    "    return gradients"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "b6f9f7593d557173167d6a84f6f678cb",
     "grade": false,
     "grade_id": "cell-4cb88cabf2344894",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Parameter Update Using Adam (momentum) (15 points)\n",
    "\n",
    "The parameter gradients $(dW,db)$ calculated during back propagation are used to update the values of the network parameters using Adam optmization which is the momentum technique we discussed in the lecture.\n",
    "\n",
    "\\begin{equation} \n",
    "V_{t+1} = \\beta V_{t} +(1-\\beta)\\nabla J(\\theta_t)\\\\ \n",
    "G_{t+1} = \\beta_2 G_{t} +(1-\\beta_2)\\nabla J(\\theta_t)^2\\\\ \n",
    "\\theta_{t+1} =\\theta_{t} -\\frac{\\alpha}{\\sqrt{G_{t+1}+\\epsilon}}V_{t+1}, \\quad \\theta \\in \\{ W,b \\} \n",
    "\\end{equation}\n",
    "\n",
    "Parameters $V$ are the momentum velocity parameters and parameters $G$ are the Gradient-Squares. \n",
    "$\\nabla J(\\theta)$ is the gradient term $dW$ or $db$, and $\\nabla  J(\\theta)^2$ is the element wise square of the gradient. \n",
    "$\\alpha$ is the step_size for gradient descent. It is has been estimated by decaying the learning_rate based on decay_rate and epoch number. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "5b17fe2a2e6d731a24e28a6235d1c389",
     "grade": false,
     "grade_id": "update_momentum_soln",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def update_parameters_with_momentum_Adam(parameters, gradients, alpha, beta=0.9, beta2=0.99, eps=1e-8):\n",
    "    '''\n",
    "    Updates the network parameters with gradient descent\n",
    "\n",
    "    Inputs:\n",
    "        parameters: dictionary of \n",
    "                    network parameters, {\"W1\":[..],\"b1\":[..],\"W2\":[..],\"b2\":[..],...}\n",
    "                    velocity parameters, {\"VdW1\":[..],\"Vdb1\":[..],\"VdW2\":[..],\"Vdb2\":[..],...}\n",
    "                    Gradient-Squares parameters, {\"GdW1\":[..],\"Gdb1\":[..],\"GdW2\":[..],\"Gdb2\":[..],...}\n",
    "                    batchnorm parameters, {\"bnorm_beta1\":[..],\"bnorm_gamma1\":[..],\"bnorm_beta2\":[..],\"bnorm_gamma2\":[..],...}\n",
    "                    batchnorm velocity parameters, {\"Vbnorm_beta1\":[..],\"Vbnorm_gamma1\":[..],\"Vbnorm_beta2\":[..],\"Vbnorm_gamma2\":[..],...}\n",
    "                    batchnorm Gradient-Square parameters, {\"Gbnorm_beta1\":[..],\"Gbnorm_gamma1\":[..],\"Gbnorm_beta2\":[..],\"Gbnorm_gamma2\":[..],...}\n",
    "                    and other parameters \n",
    "                    :\n",
    "                    :\n",
    "                    Note: It is just one dictionary (parameters) with all these key value pairs, not multiple dictionaries\n",
    "        gradients: dictionary of gradient of network parameters \n",
    "                   {\"dW1\":[..],\"db1\":[..],\"dW2\":[..],\"db2\":[..],...}\n",
    "        alpha: stepsize for the gradient descent\n",
    "        beta: beta parameter for momentum (same as beta1 in Adam)\n",
    "        beta2: beta2 parameter for Adam\n",
    "        eps: epsilon parameter for Adam\n",
    "        \n",
    "    Outputs: \n",
    "        parameters: updated dictionary of \n",
    "                    network parameters, {\"W1\":[..],\"b1\":[..],\"W2\":[..],\"b2\":[..],...}\n",
    "                    velocity parameters, {\"VdW1\":[..],\"Vdb1\":[..],\"VdW2\":[..],\"Vdb2\":[..],...}\n",
    "                    Gradient-Squares parameters, {\"GdW1\":[..],\"Gdb1\":[..],\"GdW2\":[..],\"Gdb2\":[..],...}\n",
    "                    batchnorm parameters, {\"bnorm_beta1\":[..],\"bnorm_gamma1\":[..],\"bnorm_beta2\":[..],\"bnorm_gamma2\":[..],...}\n",
    "                    batchnorm velocity parameters, {\"Vbnorm_beta1\":[..],\"Vbnorm_gamma1\":[..],\"Vbnorm_beta2\":[..],\"Vbnorm_gamma2\":[..],...}\n",
    "                    batchnorm Gradient-Square parameters, {\"Gbnorm_beta1\":[..],\"Gbnorm_gamma1\":[..],\"Gbnorm_beta2\":[..],\"Gbnorm_gamma2\":[..],...}\n",
    "                    and other parameters \n",
    "                    :\n",
    "                    :\n",
    "                    Note: It is just one dictionary (parameters) with all these key value pairs, not multiple dictionaries\n",
    "             \n",
    "    '''\n",
    "    L = parameters['numLayers']\n",
    "    apply_momentum = parameters['apply_momentum']\n",
    "    bnorm_list = parameters['bnorm_list']\n",
    "    \n",
    "    for l in range(L):\n",
    "        if apply_momentum:\n",
    "            # Apply Adam momentum to parameters W's and b's. \n",
    "            # You will need to update the Velocity parameters VdW's and Vdb's\n",
    "            \n",
    "            parameters[\"VdW\" + str(l+1)] = beta*parameters['VdW'+str(l+1)] + \\\n",
    "                                                    (1 - beta)*gradients[\"dW\"+str(l+1)]\n",
    "            parameters[\"Vdb\" + str(l+1)] = beta*parameters['Vdb'+str(l+1)] + \\\n",
    "                                                    (1 - beta)*gradients[\"db\"+str(l+1)]\n",
    "            \n",
    "            # You will need to update the Gradient-Squares parameters GdW's and Gdb's\n",
    "            \n",
    "            parameters[\"GdW\" + str(l+1)] = beta2*parameters['GdW'+str(l+1)] + \\\n",
    "                                                    (1 - beta2)*(gradients[\"dW\"+str(l+1)]**2)\n",
    "            parameters[\"Gdb\" + str(l+1)] = beta2*parameters['Gdb'+str(l+1)] + \\\n",
    "                                                    (1 - beta2)*(gradients[\"db\"+str(l+1)]**2)\n",
    "            \n",
    "            # You will need to update the parameters W's and b's\n",
    "            parameters[\"W\" + str(l+1)] -= alpha * parameters[\"VdW\" + str(l+1)]/ \\\n",
    "                                            np.sqrt(parameters[\"GdW\" + str(l+1)] + eps) \n",
    "            parameters[\"b\" + str(l+1)] -= alpha * parameters[\"Vdb\" + str(l+1)]/ \\\n",
    "                                            np.sqrt(parameters[\"Gdb\" + str(l+1)] + eps) \n",
    "            # your code here\n",
    "            \n",
    "        else:\n",
    "            # When no momentum is required apply regular gradient descent\n",
    "            parameters[\"W\"+str(l+1)] -= alpha * gradients[\"dW\"+str(l+1)]\n",
    "            parameters[\"b\"+str(l+1)] -= alpha * gradients[\"db\"+str(l+1)]\n",
    "        \n",
    "        # The Adam momentum for batch norm parameters has been implemented below\n",
    "        if apply_momentum and bnorm_list[l]:\n",
    "            parameters['Vbnorm_beta'+str(l+1)] = beta*parameters['Vbnorm_beta'+str(l+1)] + \\\n",
    "                                                    (1 - beta)*gradients[\"dbnorm_beta\"+str(l+1)]\n",
    "            parameters['Vbnorm_gamma'+str(l+1)] = beta*parameters['Vbnorm_gamma'+str(l+1)] + \\\n",
    "                                                    (1 - beta)*gradients[\"dbnorm_gamma\"+str(l+1)]\n",
    "            parameters['Gbnorm_beta'+str(l+1)] = beta2*parameters['Gbnorm_beta'+str(l+1)] + \\\n",
    "                                                    (1 - beta2)*(gradients[\"dbnorm_beta\"+str(l+1)]**2)\n",
    "            parameters['Gbnorm_gamma'+str(l+1)] = beta2*parameters['Gbnorm_gamma'+str(l+1)] + \\\n",
    "                                                    (1 - beta2)*(gradients[\"dbnorm_gamma\"+str(l+1)]**2)\n",
    "            parameters['bnorm_beta' + str(l+1)] = parameters['bnorm_beta' + str(l+1)] \\\n",
    "                        - alpha*parameters['Vbnorm_beta'+str(l+1)]/np.sqrt(parameters['Gbnorm_beta'+str(l+1)] + eps)\n",
    "            parameters['bnorm_gamma' + str(l+1)] = parameters['bnorm_gamma' + str(l+1)] \\\n",
    "                        - alpha*parameters['Vbnorm_gamma'+str(l+1)]/np.sqrt(parameters['Gbnorm_gamma'+str(l+1)] + eps)\n",
    "        elif bnorm_list[l]:\n",
    "            parameters['bnorm_beta' + str(l+1)] -= alpha * gradients[\"dbnorm_beta\"+str(l+1)]\n",
    "            parameters['bnorm_gamma' + str(l+1)] -= alpha * gradients[\"dbnorm_beta\"+str(l+1)]\n",
    "        \n",
    "    return parameters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "f97558d40b2681227c5ad08fd26599c4",
     "grade": true,
     "grade_id": "update_momentum",
     "locked": true,
     "points": 15,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "# Testing without apply_momentum\n",
    "apply_momentum_t=True\n",
    "np.random.seed(1)\n",
    "n1 = 3\n",
    "m1 = 4\n",
    "p1 = 2\n",
    "A0_t = np.random.randn(n1,m1)\n",
    "Y_t = np.array([[1., 0., 0., 1.]])\n",
    "net_dims_t = [n1,m1,p1]\n",
    "act_list_t = ['relu', 'linear']\n",
    "drop_prob_list_t = [0.3,0]\n",
    "parameters_t = initialize_network(net_dims_t, act_list_t, drop_prob_list_t)\n",
    "parameters_t = initialize_velocity(parameters_t, apply_momentum_t)\n",
    "bnorm_list_t = [0,0]\n",
    "parameters_t = initialize_bnorm_params(parameters_t, bnorm_list_t, apply_momentum_t)\n",
    "A_t, caches_t = multi_layer_forward(A0_t, parameters_t, 'train')\n",
    "AL_t,softmax_cache_t,_ = softmax_cross_entropy_loss(A_t,Y_t)\n",
    "dAL_t = softmax_cross_entropy_loss_der(Y_t, softmax_cache_t)\n",
    "gradients_t = multi_layer_backward(dAL_t, caches_t, parameters_t)\n",
    "parameters_t = update_parameters_with_momentum_Adam(parameters_t, gradients_t, alpha=1)\n",
    "parameters_t = update_parameters_with_momentum_Adam(parameters_t, gradients_t, alpha=1)\n",
    "npt.assert_array_almost_equal(parameters_t['W1'],np.array(\n",
    "      [[-2.7191573 , -2.79033829,  3.6559832 ],\n",
    "       [ 1.07680635,  2.14776979,  1.3330437 ],\n",
    "       [-2.29708863, -1.67003859, -3.38885276],\n",
    "       [ 3.66847147, -1.30571348, -1.76653199]]),decimal=6)\n",
    "npt.assert_array_almost_equal(parameters_t['b1'],np.array([[ 2.34687006],[-2.3468659 ],[-2.34495502],[-2.34646538]]),decimal=6)\n",
    "npt.assert_array_almost_equal(parameters_t['W2'],np.array(\n",
    "      [[ 3.247725  ,  1.66314062, -2.46646577,  1.41104969],\n",
    "       [-2.61475713, -1.81651301,  1.65191479, -2.74357265]]),decimal=6)\n",
    "npt.assert_array_almost_equal(parameters_t['b2'],np.array([[2.34685986],[-2.34685986]]),decimal=6)\n",
    "\n",
    "npt.assert_array_almost_equal(parameters_t['VdW1'],np.array(\n",
    "      [[ 0.04959329,  0.08954598, -0.02339858],\n",
    "       [-0.03635384, -0.13950981, -0.01346142],\n",
    "       [ 0.00538899,  0.00279682,  0.00033368],\n",
    "       [-0.01183912,  0.01798966,  0.01645148]]),decimal=6)\n",
    "npt.assert_array_almost_equal(parameters_t['Vdb1'],np.array([[-0.08461959],[0.06005603],[0.0039684 ],[0.00860207]]),decimal=6)\n",
    "npt.assert_array_almost_equal(parameters_t['GdW1'],np.array(\n",
    "      [[1.35578790e-03, 4.42016104e-03, 3.01803982e-04],\n",
    "       [7.28528402e-04, 1.07289049e-02, 9.98913468e-05],\n",
    "       [1.60088503e-05, 4.31196318e-06, 6.13777575e-08],\n",
    "       [7.72653956e-05, 1.78398694e-04, 1.49195616e-04]]),decimal=6)\n",
    "npt.assert_array_almost_equal(parameters_t['Gdb1'],np.array([[3.94718747e-03],[1.98819556e-03],[8.68115211e-06],[4.07898679e-05]]),decimal=6)\n",
    "npt.assert_array_almost_equal(parameters_t['VdW2'],np.array(\n",
    "      [[-0.07598473, -0.07214759,  0.00302548, -0.02342229],\n",
    "       [ 0.07598473,  0.07214759, -0.00302548,  0.02342229]]),decimal=6)\n",
    "npt.assert_array_almost_equal(parameters_t['Vdb2'],np.array([[-0.0457975],[0.0457975]]),decimal=6)\n",
    "npt.assert_array_almost_equal(parameters_t['GdW2'],np.array(\n",
    "      [[3.18272027e-03, 2.86938965e-03, 5.04586721e-06, 3.02415905e-04],\n",
    "       [3.18272027e-03, 2.86938965e-03, 5.04586721e-06, 3.02415905e-04]]),decimal=6)\n",
    "npt.assert_array_almost_equal(parameters_t['Gdb2'],np.array([[0.00115619],[0.00115619]]),decimal=6)\n",
    "\n",
    "# Testing without momentum\n",
    "np.random.seed(1)\n",
    "apply_momentum_t=False\n",
    "n1 = 2\n",
    "m1 = 3\n",
    "p1 = 2\n",
    "A0_t = np.random.randn(n1,m1)\n",
    "Y_t = np.array([[1., 0., 0.]])\n",
    "net_dims_t = [n1,m1,p1]\n",
    "act_list_t = ['relu', 'linear']\n",
    "drop_prob_list_t = [0.3,0]\n",
    "parameters_t = initialize_network(net_dims_t, act_list_t, drop_prob_list_t)\n",
    "parameters_t = initialize_velocity(parameters_t, apply_momentum_t)\n",
    "bnorm_list_t = [0,0]\n",
    "parameters_t = initialize_bnorm_params(parameters_t, bnorm_list_t, apply_momentum_t)\n",
    "A_t, caches_t = multi_layer_forward(A0_t, parameters_t, 'train')\n",
    "AL_t,softmax_cache_t,_ = softmax_cross_entropy_loss(A_t,Y_t)\n",
    "dAL_t = softmax_cross_entropy_loss_der(Y_t, softmax_cache_t)\n",
    "gradients_t = multi_layer_backward(dAL_t, caches_t, parameters_t)\n",
    "parameters_t = update_parameters_with_momentum_Adam(parameters_t, gradients_t, alpha=1)\n",
    "parameters_t = update_parameters_with_momentum_Adam(parameters_t, gradients_t, alpha=1)\n",
    "npt.assert_array_almost_equal(parameters_t['W1'],np.array(\n",
    "      [[ 2.38556532, -1.43370309],\n",
    "       [ 0.82922072, -0.60237324],\n",
    "       [-1.52567143, -0.53983959]]),decimal=6)\n",
    "npt.assert_array_almost_equal(parameters_t['b1'],np.array([[0.1551979 ],[0.23272841],[-2.21221693]]),decimal=6)\n",
    "npt.assert_array_almost_equal(parameters_t['W2'],np.array(\n",
    "      [[-0.16928131, -1.50183323, -4.86682037],\n",
    "       [-1.47305905,  0.85926252,  5.16232096]]),decimal=6)\n",
    "npt.assert_array_almost_equal(parameters_t['b2'],np.array([[-0.21232129],[0.21232129]]),decimal=6)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "dd7d5ca20b9bd5d6aa52f678918cd624",
     "grade": false,
     "grade_id": "cell-76abe4d415a1f55e",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Multilayer Neural Network (10 points)\n",
    "\n",
    "Let us now assemble all the components of the neural network together and define a complete training loop for a Multi-layer Neural Network."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "e0f5f0363eb77f5dd63edc993f5e1608",
     "grade": false,
     "grade_id": "multi_layer_network_soln",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def multi_layer_network(X, Y, net_dims, act_list, drop_prob_list, bnorm_list, num_epochs=3, \n",
    "                        batch_size=64, learning_rate=0.2, decay_rate=0.01, apply_momentum=True, log=True, log_step=200):\n",
    "    \n",
    "    '''\n",
    "    Creates the multilayer network and trains the network\n",
    "\n",
    "    Inputs:\n",
    "        X: numpy.ndarray (n,m) of training data\n",
    "        Y: numpy.ndarray (1,m) of training data labels\n",
    "        net_dims: tuple of layer dimensions\n",
    "        act_list: list of strings indicating the activations for each layer\n",
    "        drop_prob_list: list of dropout probabilities for each layer \n",
    "        bnorm_list: binary list indicating presence or absence of batchnorm for each layer\n",
    "        num_epochs: num of epochs to train\n",
    "        batch_size: batch size for training\n",
    "        learning_rate: learning rate for gradient descent\n",
    "        decay_rate: rate of learning rate decay\n",
    "        apply_momentum: boolean whether to apply momentum or not\n",
    "        log: boolean whether to print training progression \n",
    "        log_step: prints training progress every log_step iterations\n",
    "    \n",
    "    Outputs:\n",
    "        costs: list of costs (or loss) over training\n",
    "        parameters: dictionary of \n",
    "                    network parameters, {\"W1\":[..],\"b1\":[..],\"W2\":[..],\"b2\":[..],...}\n",
    "                    velocity parameters, {\"VdW1\":[..],\"Vdb1\":[..],\"VdW2\":[..],\"Vdb2\":[..],...}\n",
    "                    Gradient-Squares parameters, {\"GdW1\":[..],\"Gdb1\":[..],\"GdW2\":[..],\"Gdb2\":[..],...}\n",
    "                    batchnorm parameters, {\"bnorm_beta1\":[..],\"bnorm_gamma1\":[..],\"bnorm_beta2\":[..],\"bnorm_gamma2\":[..],...}\n",
    "                    batchnorm velocity parameters, {\"Vbnorm_beta1\":[..],\"Vbnorm_gamma1\":[..],\"Vbnorm_beta2\":[..],\"Vbnorm_gamma2\":[..],...}\n",
    "                    batchnorm Gradient-Square parameters, {\"Gbnorm_beta1\":[..],\"Gbnorm_gamma1\":[..],\"Gbnorm_beta2\":[..],\"Gbnorm_gamma2\":[..],...}\n",
    "                    Note: It is just one dictionary (parameters) with all these key value pairs, not multiple dictionaries\n",
    "    '''\n",
    "    mode = 'train'\n",
    "    n, m = X.shape\n",
    "    parameters = initialize_network(net_dims, act_list, drop_prob_list)\n",
    "    parameters = initialize_velocity(parameters, apply_momentum)\n",
    "    parameters = initialize_bnorm_params(parameters, bnorm_list, apply_momentum)\n",
    "    costs = []\n",
    "    itr = 0\n",
    "    for epoch in range(num_epochs):\n",
    "        # estimate stepsize alpha using decay_rate on learning rate using epoch number\n",
    "        alpha = learning_rate*(1/(1+decay_rate*epoch))\n",
    "        if log:\n",
    "            print('------- Epoch {} -------'.format(epoch+1))\n",
    "        for ii in range((m - 1) // batch_size + 1):\n",
    "            Xb = X[:, ii*batch_size : (ii+1)*batch_size]\n",
    "            Yb = Y[:, ii*batch_size : (ii+1)*batch_size]\n",
    "            A0 = Xb\n",
    "        \n",
    "            ## Forward Propagation\n",
    "            # Step 1: Input 'A0', 'parameters' and 'mode' into the network \n",
    "            #         using multi_layer_forward() and calculate output of last layer 'A' (before softmax) \n",
    "            #         and obtain cached activations as 'caches'\n",
    "            # Step 2: Input 'A' and groundtruth labels 'Yb' to softmax_cros_entropy_loss(.) and estimate\n",
    "            #         activations 'AL', 'softmax_cache' and 'cost'\n",
    "\n",
    "            ## Back Propagation\n",
    "            # Step 3: Estimate gradient 'dAL' with softmax_cros_entropy_loss_der(.) using groundtruth \n",
    "            #         labels 'Yb' and 'softmax_cache' \n",
    "            # Step 4: Estimate 'gradients' with multi_layer_backward(.) using 'dAL', 'caches' and 'parameters' \n",
    "            # Step 5: Estimate updated 'parameters' with update_parameters_with_momentum_Adam(.) \n",
    "            #         using 'parameters', 'gradients' and 'alpha'\n",
    "            #         Note: Use the same variable 'parameters' as input and output to the update_parameters(.) function\n",
    "        \n",
    "            # your code here\n",
    "            A, caches = multi_layer_forward(A0, parameters, mode)\n",
    "            AL, softmax_cache, cost = softmax_cross_entropy_loss(A, Yb)\n",
    "            dAL = softmax_cross_entropy_loss_der(Yb, softmax_cache)\n",
    "            gradients = multi_layer_backward(dAL, caches, parameters)\n",
    "            parameters = update_parameters_with_momentum_Adam(parameters, gradients, alpha)\n",
    "            \n",
    "\n",
    "            if itr % log_step == 0:\n",
    "                costs.append(cost)\n",
    "                if log:\n",
    "                    print(\"Cost at iteration %i is: %.05f, learning rate: %.05f\" %(itr, cost, alpha))\n",
    "            itr+=1\n",
    "    \n",
    "    return costs, parameters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "d5b30052c20c8d00b5334fb1161a632d",
     "grade": true,
     "grade_id": "cell-multi_layer_network",
     "locked": true,
     "points": 10,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "np.random.seed(1)\n",
    "n1 = 3\n",
    "m1 = 6\n",
    "p1 = 3\n",
    "A0_t = np.random.randn(n1,m1)\n",
    "Y_t = np.array([[1., 0., 2., 0, 1., 2.]])\n",
    "net_dims_t = [n1,m1,p1]\n",
    "act_list_t = ['relu', 'linear']\n",
    "drop_prob_list_t = [0.3,0]\n",
    "bnorm_list_t = [0,0]\n",
    "num_epochs_t = 1\n",
    "batch_size_t = 2\n",
    "learning_rate_t = 1e-1\n",
    "decay_rate_t = 1\n",
    "apply_momentum_t = True\n",
    "costs_est, parameters_est = multi_layer_network(A0_t, Y_t, net_dims_t, act_list_t, drop_prob_list_t, bnorm_list_t, \\\n",
    "                                        num_epochs=num_epochs_t, batch_size=batch_size_t, learning_rate=learning_rate_t, \\\n",
    "                                        decay_rate=decay_rate_t, apply_momentum=apply_momentum_t, log=False, log_step=1)\n",
    "npt.assert_array_almost_equal(costs_est,np.array([0.8291501476754569, 3.1183677832322285, 4.988510889921268]),decimal=6)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "8258b52466398b97d07c4fac54a14329",
     "grade": false,
     "grade_id": "cell-66defde04ecba045",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Prediction (5 points)\n",
    "\n",
    "This is the evaluation function which will predict the labels for a minibatch of inputs samples\n",
    "We will perform forward propagation through the entire network and determine the class predictions for the input data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "c648f2b41d8b9602fac153cb151e1127",
     "grade": false,
     "grade_id": "classify_soln",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def classify(X, parameters, mode='test'):\n",
    "    '''\n",
    "    Network prediction for inputs X\n",
    "\n",
    "    Inputs: \n",
    "        X: numpy.ndarray (n,m) with n features and m samples\n",
    "        parameters: dictionary of network parameters \n",
    "            {\"W1\":[..],\"b1\":[..],\"W2\":[..],\"b2\":[..],...}\n",
    "        drop_prob_list: list of dropout probabilities for each layer \n",
    "        mode: 'train' or 'test' Dropout acts differently in training and testing mode.\n",
    "        \n",
    "    Outputs:\n",
    "        YPred: numpy.ndarray (1,m) of predictions\n",
    "    '''\n",
    "    # Using multi_layer_forward(.) Forward propagate input 'X' with 'parameters' and mode to \n",
    "    #        obtain the final activation 'A'\n",
    "    # Using 'softmax_cross_entropy loss(.)', obtain softmax activation 'AL' with input 'A' from step 1\n",
    "    # Estimate 'YPred' as the 'argmax' of softmax activation from step-2. These are the label predictions \n",
    "    # Note: the shape of 'YPred' should be (1,m), where m is the number of samples\n",
    "    \n",
    "    # your code here\n",
    "    A, caches = multi_layer_forward(X, parameters,mode)\n",
    "    AL,cache,loss = softmax_cross_entropy_loss(A)\n",
    "    YPred = np.array([])\n",
    "    YPred = np.argmax(AL, axis=0)\n",
    "    YPred = YPred.reshape(-1, YPred.size)    \n",
    "    return YPred"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "b18208760c4d806ebc58b7aba782f149",
     "grade": true,
     "grade_id": "classify",
     "locked": true,
     "points": 5,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "#Hidden test cases follow\n",
    "np.random.seed(1)\n",
    "n1 = 3\n",
    "m1 = 4\n",
    "p1 = 2\n",
    "X_t = np.random.randn(n1,m1)\n",
    "net_dims_t = [n1,m1,p1]\n",
    "act_list_t = ['relu', 'linear']\n",
    "drop_prob_list = [0.3,0]\n",
    "parameters_t = initialize_network(net_dims_t, act_list_t, drop_prob_list)\n",
    "bnorm_list_t = [0,0]\n",
    "parameters_t = initialize_bnorm_params(parameters_t, bnorm_list_t, False)\n",
    "#parameters_t = {'W1':W1_t, 'b1':b1_t, 'W2':W2_t, 'b2':b2_t, 'numLayers':2, 'act1':'relu', 'act2':'linear'}\n",
    "YPred_est = classify(X_t, parameters_t)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "0a8d461d5399d9e219915a9fb4744e46",
     "grade": false,
     "grade_id": "cell-f44aae42add8fd84",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Training (10 points)\n",
    "\n",
    "We will now intialize a neural network with 3 hidden layers whose dimensions are 100, 100 and 64. \n",
    "Since the input samples are of dimension 28 $\\times$ 28, the input layer will be of dimension 784. The output dimension is 10 since we have a 10 category classification. \n",
    "We will train the model and compute its accuracy on both training and test sets and plot the training cost (or loss) against the number of iterations. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "e838550fae62d69a1a9965e4800dfd35",
     "grade": false,
     "grade_id": "test_acc_soln",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Network dimensions are:[784, 100, 100, 64, 10]\n",
      "Dropout= [[0, 0, 0, 0]], Batch Size = 64, lr = 0.01, decay rate = 1\n",
      "------- Epoch 1 -------\n",
      "Cost at iteration 0 is: 3.19439, learning rate: 0.01000\n",
      "Cost at iteration 200 is: 0.69714, learning rate: 0.01000\n",
      "Cost at iteration 400 is: 0.33321, learning rate: 0.01000\n",
      "Cost at iteration 600 is: 0.16808, learning rate: 0.01000\n",
      "Cost at iteration 800 is: 0.17616, learning rate: 0.01000\n",
      "------- Epoch 2 -------\n",
      "Cost at iteration 1000 is: 0.22808, learning rate: 0.00500\n",
      "Cost at iteration 1200 is: 0.29536, learning rate: 0.00500\n",
      "Cost at iteration 1400 is: 0.10199, learning rate: 0.00500\n",
      "Cost at iteration 1600 is: 0.19070, learning rate: 0.00500\n",
      "Cost at iteration 1800 is: 0.16993, learning rate: 0.00500\n",
      "------- Epoch 3 -------\n",
      "Cost at iteration 2000 is: 0.06496, learning rate: 0.00333\n",
      "Cost at iteration 2200 is: 0.35241, learning rate: 0.00333\n",
      "Cost at iteration 2400 is: 0.09339, learning rate: 0.00333\n",
      "Cost at iteration 2600 is: 0.25355, learning rate: 0.00333\n",
      "Cost at iteration 2800 is: 0.01925, learning rate: 0.00333\n",
      "Accuracy for training set is 96.890 %\n",
      "Accuracy for testing set is 96.100 %\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "# You should be able to get a train accuracy of >90% and a test accuracy >85% \n",
    "# The settings below gave >95% train accuracy and >90% test accuracy \n",
    "\n",
    "# Feel free to adjust the values and explore how the network behaves\n",
    "net_dims = [784, 100, 100, 64, 10] # This network has 4 layers\n",
    "#784 is for image dimensions\n",
    "#10 is for number of categories \n",
    "#100 and 64 are arbitrary\n",
    "\n",
    "# list of dropout probabilities for each layer\n",
    "# The length of the list is equal to the number of layers\n",
    "# Note: Has to be same length as net_dims. 0 indicates no dropout\n",
    "drop_prob_list = [0, 0, 0, 0]\n",
    "\n",
    "# binary list indicating if batchnorm should be implemented for a layer\n",
    "# The length of the list is equal to the number of layers\n",
    "# 1 indicates bathnorm and 0 indicates no batchnorm\n",
    "# If your implementation of batchnorm is incorrect, then set bnorm_list = [0,0,0,0]\n",
    "bnorm_list = [1,1,1,1]\n",
    "assert(len(bnorm_list) == len(net_dims)-1)\n",
    "\n",
    "# list of strings indicating the activation for a layer\n",
    "# The length of the list is equal to the number of layers\n",
    "# The last layer is usually a linear before the softmax\n",
    "act_list = ['relu', 'relu', 'relu', 'linear']\n",
    "assert(len(act_list) == len(net_dims)-1)\n",
    "    \n",
    "# initialize learning rate, decay_rate and num_iterations \n",
    "num_epochs = 3\n",
    "batch_size = 64\n",
    "learning_rate = 1e-2\n",
    "decay_rate = 1\n",
    "apply_momentum = True\n",
    "\n",
    "np.random.seed(1)\n",
    "\n",
    "print(\"Network dimensions are:\" + str(net_dims))\n",
    "print('Dropout= [{}], Batch Size = {}, lr = {}, decay rate = {}'\\\n",
    "      .format(drop_prob_list,batch_size,learning_rate,decay_rate)) \n",
    "\n",
    "# getting the subset dataset from MNIST\n",
    "trX, trY, tsX, tsY = get_mnist()\n",
    "# We need to reshape the data everytime to match the format (d,m), where d is dimensions (784) and m is number of samples\n",
    "trX = trX.reshape(-1, 28*28).T\n",
    "trY = trY.reshape(1, -1)\n",
    "tsX = tsX.reshape(-1, 28*28).T\n",
    "tsY = tsY.reshape(1, -1)\n",
    "\n",
    "costs, parameters = multi_layer_network(trX, trY, net_dims, act_list, drop_prob_list, bnorm_list, \\\n",
    "                                        num_epochs=num_epochs, batch_size=batch_size, learning_rate=learning_rate, \\\n",
    "                                        decay_rate=decay_rate, apply_momentum=apply_momentum, log=True)\n",
    "\n",
    "# compute the accuracy for training set and testing set\n",
    "train_Pred = classify(trX, parameters)\n",
    "\n",
    "test_Pred = classify(tsX, parameters)\n",
    "\n",
    "# Estimate the training accuracy 'trAcc' comparing train_Pred and trY \n",
    "# Estimate the testing accuracy 'teAcc' comparing test_Pred and tsY\n",
    "# your code here\n",
    "\n",
    "if trY.size!=0:\n",
    "        trAcc = np.mean(train_Pred==trY)*100\n",
    "if tsY.size!=0:\n",
    "        teAcc = np.mean(test_Pred==tsY)*100\n",
    "\n",
    "print(\"Accuracy for training set is {0:0.3f} %\".format(trAcc))\n",
    "print(\"Accuracy for testing set is {0:0.3f} %\".format(teAcc))\n",
    "\n",
    "plt.plot(range(len(costs)),costs)\n",
    "plt.xlabel(\"Iterations\")\n",
    "plt.ylabel(\"Loss\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [],
   "source": [
    "# The following set up gives an accuracy of > 96% for both test and train. \n",
    "# Feel free to change the settings to get the best accuracy \n",
    "np.random.seed(1)\n",
    "\n",
    "net_dims = [784, 100, 100, 10] \n",
    "drop_prob_list = [0, 0, 0]\n",
    "act_list = ['relu', 'relu', 'linear']\n",
    "    \n",
    "# initialize learning rate, decay_rate and num_iterations \n",
    "num_epochs = 3\n",
    "batch_size = 64\n",
    "learning_rate = 1e-3\n",
    "decay_rate = 0.1\n",
    "apply_momentum = True\n",
    "\n",
    "# If your implementation of batchnorm is incorrect, \n",
    "# then set bnorm_list = [0,0,0] below to run the following testcase without batchnorm. \n",
    "# bnorm_list = [1 1 1] - initially \n",
    "# The test case is still expected to pass without batchnorm when your accuracy is above 95%\n",
    "bnorm_list = [1,1,1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "64e37b89e48e9733c099ea03a0aedf51",
     "grade": true,
     "grade_id": "test_acc",
     "locked": true,
     "points": 10,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "# getting the subset dataset from MNIST\n",
    "trX, trY, tsX, tsY = get_mnist()\n",
    "# We need to reshape the data everytime to match the format (d,m), where d is dimensions (784) and m is number of samples\n",
    "trX = trX.reshape(-1, 28*28).T\n",
    "trY = trY.reshape(1, -1)\n",
    "tsX = tsX.reshape(-1, 28*28).T\n",
    "tsY = tsY.reshape(1, -1)\n",
    "\n",
    "costs, parameters = multi_layer_network(trX, trY, net_dims, act_list, drop_prob_list, bnorm_list, \\\n",
    "                                        num_epochs=num_epochs, batch_size=batch_size, learning_rate=learning_rate, \\\n",
    "                                        decay_rate=decay_rate, apply_momentum=apply_momentum, log=False)\n",
    "\n",
    "# compute the accuracy for training set and testing set\n",
    "train_Pred = classify(trX, parameters)\n",
    "test_Pred = classify(tsX, parameters)\n",
    "\n",
    "# Contains hidden tests \n",
    "# Should get atleast 95% train and test accuracy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Accuracy for training set is 97.142 %\n",
      "Accuracy for testing set is 96.640 %\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "if trY.size!=0:\n",
    "        trAcc = np.mean(train_Pred==trY)*100\n",
    "if tsY.size!=0:\n",
    "        teAcc = np.mean(test_Pred==tsY)*100\n",
    "\n",
    "print(\"Accuracy for training set is {0:0.3f} %\".format(trAcc))\n",
    "print(\"Accuracy for testing set is {0:0.3f} %\".format(teAcc))\n",
    "\n",
    "plt.plot(range(len(costs)),costs)\n",
    "plt.xlabel(\"Iterations\")\n",
    "plt.ylabel(\"Loss\")\n",
    "plt.show()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
